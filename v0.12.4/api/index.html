<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · OndaEDF</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OndaEDF</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">OndaEDF</a></li><li><a class="tocitem" href="../convert-to-onda/">Converting from EDF</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Import-EDF-to-Onda"><span>Import EDF to Onda</span></a></li><li><a class="tocitem" href="#Export-EDF-from-Onda"><span>Export EDF from Onda</span></a></li><li><a class="tocitem" href="#Deprecations"><span>Deprecations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Import-EDF-to-Onda"><a class="docs-heading-anchor" href="#Import-EDF-to-Onda">Import EDF to Onda</a><a id="Import-EDF-to-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#Import-EDF-to-Onda" title="Permalink"></a></h2><p>OndaEDF.jl prefers &quot;self-service&quot; import over &quot;automagic&quot;, and provides functionality to extract <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Samples-1"><code>Onda.Samples</code></a> and <a href="#OndaEDFSchemas.EDFAnnotationV1"><code>EDFAnnotationV1</code></a>s (which extend  <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Onda.AnnotationV1"><code>Onda.AnnotationV1</code></a>s) from an <code>EDF.File</code>.  These can be written to disk (with <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Onda.store"><code>Onda.store</code></a> / <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.write"><code>Legolas.write</code></a> or manipulated in memory as desired.</p><h3 id="Import-signal-data-as-Samples"><a class="docs-heading-anchor" href="#Import-signal-data-as-Samples">Import signal data as <code>Samples</code></a><a id="Import-signal-data-as-Samples-1"></a><a class="docs-heading-anchor-permalink" href="#Import-signal-data-as-Samples" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.edf_to_onda_samples" href="#OndaEDF.edf_to_onda_samples"><code>OndaEDF.edf_to_onda_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edf_to_onda_samples(edf::EDF.File, plan_table; validate=true, dither_storage=missing)</code></pre><p>Convert Signals found in an EDF File to <code>Onda.Samples</code> according to the plan specified in <code>plan_table</code> (e.g., as generated by <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>), returning an iterable of the generated <code>Onda.Samples</code> and the plan as actually executed.</p><p>The input plan is transformed by using <a href="#OndaEDF.merge_samples_info"><code>merge_samples_info</code></a> to combine rows with the same <code>:onda_signal_index</code> into a common <code>Onda.SamplesInfo</code>.  Then <a href="#OndaEDF.onda_samples_from_edf_signals"><code>OndaEDF.onda_samples_from_edf_signals</code></a> is used to combine the EDF signals data into a single <code>Onda.Samples</code> per group.</p><p>Any errors that occur are shown as <code>String</code>s (with backtrace) and inserted into the <code>:error</code> column for the corresponding rows from the plan.</p><p>Samples are returned in the order of <code>:onda_signal_index</code>.  Signals that could not be matched or otherwise caused an error during execution are not returned.</p><p>If <code>validate=true</code> (the default), the plan is validated against the <a href="#OndaEDFSchemas.FilePlanV2"><code>FilePlanV2</code></a> schema, and the signal headers in the <code>EDF.File</code>.</p><p>If <code>dither_storage=missing</code> (the default), dither storage is allocated automatically as specified in the docstring for <code>Onda.encode</code>. <code>dither_storage=nothing</code> disables dithering.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Returned samples are integer-encoded. If these samples are being serialized out (e.g. via <code>Onda.store!</code>) this is not an issue, but if the samples are being immediately analyzed in memory, call <code>Onda.decode</code> to decode them to recover the time-series voltages.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L501-L526">source</a></section><section><div><pre><code class="language-none">edf_to_onda_samples(edf::EDF.File; kwargs...)</code></pre><p>Read signals from an <code>EDF.File</code> into a vector of <code>Onda.Samples</code>.  This is a convenience function that first formulates an import plan via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>, and then immediately executes this plan with <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.</p><p>The samples and executed plan are returned; it is <strong>strongly advised</strong> that you review the plan for un-extracted signals (where <code>:sensor_type</code> or <code>:channel</code> is <code>missing</code>) and errors (non-<code>nothing</code> values in <code>:error</code>).</p><p>Collections of <code>EDF.Signal</code>s are mapped as channels to <code>Onda.Samples</code> via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  The caller of this function can control the plan via the <code>labels</code> and <code>units</code> keyword arguments, all of which are forwarded to <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.</p><p><code>EDF.Signal</code> labels that are converted into Onda channel names undergo the following transformations:</p><ul><li>the label is whitespace-stripped, parens-stripped, and lowercased</li><li>trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.) are dropped</li><li>any instance of <code>+</code> is replaced with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>all component names are converted to their &quot;canonical names&quot; when possible (e.g. &quot;m1&quot; in an EEG-matched channel name will be converted to &quot;a1&quot;).</li></ul><p>See the OndaEDF README for additional details regarding EDF formatting expectations.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Returned samples are integer-encoded. If these samples are being serialized out (e.g. via <code>Onda.store!</code>) this is not an issue, but if the samples are being immediately analyzed in memory, call <code>Onda.decode</code> to decode them to recover the time-series voltages.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L788-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.plan_edf_to_onda_samples" href="#OndaEDF.plan_edf_to_onda_samples"><code>OndaEDF.plan_edf_to_onda_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_edf_to_onda_samples(header, seconds_per_record; labels=STANDARD_LABELS,
                         units=STANDARD_UNITS)
plan_edf_to_onda_samples(signal::EDF.Signal, args...; kwargs...)</code></pre><p>Formulate a plan for converting an EDF signal into Onda format.  This returns a Tables.jl row with all the columns from the signal header, plus additional columns for the <code>Onda.SamplesInfo</code> for this signal, and the <code>seconds_per_record</code> that is passed in here.</p><p>If no labels match, then the <code>channel</code> and <code>kind</code> columns are <code>missing</code>; the behavior of other <code>SamplesInfo</code> columns is undefined; they are currently set to missing but that may change in future versions.</p><p>Any errors that are thrown in the process will be wrapped as <code>SampleInfoError</code>s and then printed with backtrace to a <code>String</code> in the <code>error</code> column.</p><p><strong>Matching EDF label to Onda labels</strong></p><p>The <code>labels</code> keyword argument determines how Onda <code>channel</code> and signal <code>kind</code> are extracted from the EDF label.</p><p>Labels are specified as an iterable of <code>signal_names =&gt; channel_names</code> pairs. <code>signal_names</code> should be an iterable of signal names, the first of which is the canonical name used as the Onda <code>kind</code>.  Each element of <code>channel_names</code> gives the specification for one channel, which can either be a string, or a <code>canonical_name =&gt; alternates</code> pair.  Occurences of <code>alternates</code> will be replaces with <code>canonical_name</code> in the generated channel label.</p><p>Matching is determined <em>solely</em> by the channel names.  When matching, the signal names are only used to remove signal names occuring as prefixes (e.g., &quot;[ECG] AVL&quot;) before matching channel names.  See <a href="#OndaEDF.match_edf_label"><code>match_edf_label</code></a> for details, and see <code>OndaEDF.STANDARD_LABELS</code> for the default labels.</p><p>As an example, here is (a subset of) the default labels for ECG signals:</p><pre><code class="language-julia">[&quot;ecg&quot;, &quot;ekg&quot;] =&gt; [&quot;i&quot; =&gt; [&quot;1&quot;], &quot;ii&quot; =&gt; [&quot;2&quot;], &quot;iii&quot; =&gt; [&quot;3&quot;],
                   &quot;avl&quot;=&gt; [&quot;ecgl&quot;, &quot;ekgl&quot;, &quot;ecg&quot;, &quot;ekg&quot;, &quot;l&quot;], 
                   &quot;avr&quot;=&gt; [&quot;ekgr&quot;, &quot;ecgr&quot;, &quot;r&quot;], ...]</code></pre><p>Matching is done in the order that <code>labels</code> iterates pairs, and will stop at the first match, with no warning if signals are ambiguous (although this may change in a future version)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L304-L349">source</a></section><section><div><pre><code class="language-none">plan_edf_to_onda_samples(edf::EDF.File;
                         labels=STANDARD_LABELS,
                         units=STANDARD_UNITS,
                         onda_signal_groupby=(:sensor_type, :sample_unit, :sample_rate))</code></pre><p>Formulate a plan for converting an <code>EDF.File</code> to Onda Samples.  This applies <code>plan_edf_to_onda_samples</code> to each individual signal contained in the file, storing <code>edf_signal_index</code> as an additional column.  </p><p>The resulting rows are then passed to <a href="#OndaEDF.plan_edf_to_onda_samples_groups"><code>plan_edf_to_onda_samples_groups</code></a> and grouped according to <code>onda_signal_groupby</code> (by default, the <code>:sensor_type</code>, <code>:sample_unit</code>, and <code>:sample_rate</code> columns), and the group index is added as an additional column in <code>onda_signal_index</code>.</p><p>The resulting plan is returned as a table.  No signal data is actually read from the EDF file; to execute this plan and generate <code>Onda.Samples</code>, use <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.  The index of the EDF signal (after filtering out signals that are not <code>EDF.Signal</code>s, e.g. annotation channels) for each row is stored in the <code>:edf_signal_index</code> column, and the rows are sorted in order of <code>:onda_signal_index</code>, and then by <code>:edf_signal_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L413-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.plan_edf_to_onda_samples_groups" href="#OndaEDF.plan_edf_to_onda_samples_groups"><code>OndaEDF.plan_edf_to_onda_samples_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_edf_to_onda_samples_groups(plan_rows; onda_signal_groupby=(:sensor_type, :sample_unit, :sample_rate))</code></pre><p>Group together <code>plan_rows</code> based on the values of the <code>onda_signal_groupby</code> columns, creating the <code>:onda_signal_index</code> column and promoting the Onda encodings for each group using <a href="#OndaEDF.promote_encodings"><code>OndaEDF.promote_encodings</code></a>.</p><p>If the <code>:edf_signal_index</code> column is not present or otherwise missing, it will be filled in based on the order of the input rows.</p><p>The updated rows are returned, sorted first by the columns named in <code>onda_signal_groupby</code> and second by order of occurrence within the input rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L461-L473">source</a></section></article><h3 id="Import-annotations"><a class="docs-heading-anchor" href="#Import-annotations">Import annotations</a><a id="Import-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Import-annotations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.edf_to_onda_annotations" href="#OndaEDF.edf_to_onda_annotations"><code>OndaEDF.edf_to_onda_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edf_to_onda_annotations(edf::EDF.File, uuid::UUID)</code></pre><p>Extract EDF+ annotations from an <code>EDF.File</code> for recording with ID <code>uuid</code> and return them as a vector of <code>Onda.Annotation</code>s.  Each returned annotation has a  <code>value</code> field that contains the string value of the corresponding EDF+ annotation.</p><p>If no EDF+ annotations are found in <code>edf</code>, then an empty <code>Vector{Annotation}</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L824-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.EDFAnnotationV1" href="#OndaEDFSchemas.EDFAnnotationV1"><code>OndaEDFSchemas.EDFAnnotationV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version EDFAnnotationV1 &gt; AnnotationV1 begin
    value::String
end</code></pre><p>A Legolas-generated record type that represents a single annotation imported from an EDF Annotation signal.  The <code>value</code> field contains the annotation value as a string.</p></div></section></article><h3 id="Import-plan-table-schemas"><a class="docs-heading-anchor" href="#Import-plan-table-schemas">Import plan table schemas</a><a id="Import-plan-table-schemas-1"></a><a class="docs-heading-anchor-permalink" href="#Import-plan-table-schemas" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.PlanV2" href="#OndaEDFSchemas.PlanV2"><code>OndaEDFSchemas.PlanV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version PlanV2 begin
    # EDF.SignalHeader fields
    label::String
    transducer_type::String
    physical_dimension::String
    physical_minimum::Float32
    physical_maximum::Float32
    digital_minimum::Float32
    digital_maximum::Float32
    prefilter::String
    samples_per_record::Int16
    # EDF.FileHeader field
    seconds_per_record::Float64
    # Onda.SignalV2 fields (channels -&gt; channel), may be missing
    recording::Union{UUID,Missing} = passmissing(UUID)
    sensor_type::Union{Missing,AbstractString}
    sensor_label::Union{Missing,AbstractString}
    channel::Union{Missing,AbstractString}
    sample_unit::Union{Missing,AbstractString}
    sample_resolution_in_unit::Union{Missing,Float64}
    sample_offset_in_unit::Union{Missing,Float64}
    sample_type::Union{Missing,AbstractString}
    sample_rate::Union{Missing,Float64}
    # errors, use `nothing` to indicate no error
    error::Union{Nothing,String}
end</code></pre><p>A Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of</p><ul><li>fields from <code>EDF.SignalHeader</code> (all mandatory)</li><li>the <code>seconds_per_record</code> field from <code>EDF.FileHeader</code> (mandatory)</li><li>fields from <code>Onda.SignalV2</code> (optional, may be <code>missing</code> to indicate failed conversion), except for <code>file_path</code></li><li><code>error</code>, which is <code>nothing</code> for a conversion that is or is expected to be successful, and a <code>String</code> describing the source of the error (with backtrace) in the case of a caught error.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.FilePlanV2" href="#OndaEDFSchemas.FilePlanV2"><code>OndaEDFSchemas.FilePlanV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version FilePlanV2 &gt; PlanV2 begin
    edf_signal_index::Int
    onda_signal_index::Int
end</code></pre><p>A Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a <a href="#OndaEDFSchemas.PlanV2"><code>PlanV2</code></a> and additional file-level context:</p><ul><li><code>edf_signal_index</code> gives the index of the <code>signals</code> in the source <code>EDF.File</code> corresponding to this row</li><li><code>onda_signal_index</code> gives the index of the output <code>Onda.Samples</code>.</li></ul><p>Note that while the EDF index does correspond to the actual index in <code>edf.signals</code>, some Onda indices may be skipped in the output, so <code>onda_signal_index</code> is only to indicate order and grouping.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.write_plan" href="#OndaEDF.write_plan"><code>OndaEDF.write_plan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_plan(io_or_path, plan_table; validate=true, kwargs...)</code></pre><p>Write a plan table to <code>io_or_path</code> using <code>Legolas.write</code>, using the <code>ondaedf.file-plan@1</code> schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/OndaEDF.jl#L24-L29">source</a></section></article><h3 id="Full-service-import"><a class="docs-heading-anchor" href="#Full-service-import">Full-service import</a><a id="Full-service-import-1"></a><a class="docs-heading-anchor-permalink" href="#Full-service-import" title="Permalink"></a></h3><p>For a more &quot;full-service&quot; experience, OndaEDF.jl also provides functionality to extract <code>Onda.Samples</code> and <code>EDFAnnotationV1</code>s and then write them to disk:</p><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.store_edf_as_onda" href="#OndaEDF.store_edf_as_onda"><code>OndaEDF.store_edf_as_onda</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store_edf_as_onda(edf::EDF.File, onda_dir, recording_uuid::UUID=uuid4();
                  custom_extractors=STANDARD_EXTRACTORS, import_annotations::Bool=true,
                  postprocess_samples=identity,
                  signals_prefix=&quot;edf&quot;, annotations_prefix=signals_prefix)</code></pre><p>Convert an EDF.File to <code>Onda.Samples</code> and <code>Onda.Annotation</code>s, store the samples in <code>$path/samples/</code>, and write the Onda signals and annotations tables to <code>$path/$(signals_prefix).onda.signals.arrow</code> and <code>$path/$(annotations_prefix).onda.annotations.arrow</code>.  The default prefix is &quot;edf&quot;, and if a prefix is provided for signals but not annotations both will use the signals prefix.  The prefixes cannot reference (sub)directories.</p><p>Returns <code>(; recording_uuid, signals, annotations, signals_path, annotations_path, plan)</code>.</p><p>This is a convenience function that first formulates an import plan via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>, and then immediately executes this plan with <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.</p><p>The samples and executed plan are returned; it is <strong>strongly advised</strong> that you review the plan for un-extracted signals (where <code>:sensor_type</code> or <code>:channel</code> is <code>missing</code>) and errors (non-<code>nothing</code> values in <code>:error</code>).</p><p>Groups of <code>EDF.Signal</code>s are mapped as channels to <code>Onda.Samples</code> via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  The caller of this function can control the plan via the <code>labels</code> and <code>units</code> keyword arguments, all of which are forwarded to <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.</p><p><code>EDF.Signal</code> labels that are converted into Onda channel names undergo the following transformations:</p><ul><li>the label is whitespace-stripped, parens-stripped, and lowercased</li><li>trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.) are dropped</li><li>any instance of <code>+</code> is replaced with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>all component names are converted to their &quot;canonical names&quot; when possible (e.g. &quot;3&quot; in an ECG-matched channel name will be converted to &quot;iii&quot;).</li></ul><p>If more control (e.g. preprocessing signal labels) is required, callers should use <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a> and <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a> directly, and <code>Onda.store</code> the resulting samples manually.</p><p>See the OndaEDF README for additional details regarding EDF formatting expectations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L679-L721">source</a></section></article><h3 id="Internal-import-utilities"><a class="docs-heading-anchor" href="#Internal-import-utilities">Internal import utilities</a><a id="Internal-import-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-import-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.match_edf_label" href="#OndaEDF.match_edf_label"><code>OndaEDF.match_edf_label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.match_edf_label(label, signal_names, channel_name, canonical_names)</code></pre><p>Return a normalized label matched from an EDF <code>label</code>.  The purpose of this function is to remove signal names from the label, and to canonicalize the channel name(s) that remain.  So something like &quot;[eCG] avl-REF&quot; will be transformed to &quot;avl&quot; (given <code>signal_names=[&quot;ecg&quot;]</code>, and <code>channel_name=&quot;avl&quot;</code>)</p><p>This returns <code>nothing</code> if <code>channel_name</code> does not match after normalization.</p><p>Canonicalization</p><ul><li>ensures the given label is whitespace-stripped, lowercase, and parens-free</li><li>strips trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.)</li><li>replaces all references with the appropriate name as specified by <code>canonical_names</code></li><li>replaces <code>+</code> with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>returns the initial reference name (w/o prefix sign, if present) and the entire label; the initial reference name should match the canonical channel name, otherwise the channel extraction will be rejected.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">match_edf_label(&quot;[ekG]  avl-REF&quot;, [&quot;ecg&quot;, &quot;ekg&quot;], &quot;avl&quot;, []) == &quot;avl&quot;
match_edf_label(&quot;ECG 2&quot;, [&quot;ecg&quot;, &quot;ekg&quot;], &quot;ii&quot;, [&quot;ii&quot; =&gt; [&quot;2&quot;, &quot;two&quot;, &quot;ecg2&quot;]]) == &quot;ii&quot;</code></pre><p>See the tests for more examples</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called directly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L81-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.merge_samples_info" href="#OndaEDF.merge_samples_info"><code>OndaEDF.merge_samples_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.merge_samples_info(plan_rows)</code></pre><p>Create a single, merged <code>SamplesInfo</code> from plan rows, such as generated by <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  Encodings are promoted with <code>promote_encodings</code>.</p><p>The input rows must have the same values for <code>:sensor_type</code>, <code>:sample_unit</code>, and <code>:sample_rate</code>; otherwise an <code>ArgumentError</code> is thrown.</p><p>If any of these values is <code>missing</code>, or any row&#39;s <code>:channel</code> value is <code>missing</code>, this returns <code>missing</code> to indicate it is not possible to determine a shared <code>SamplesInfo</code>.</p><p>The original EDF labels are included in the output in the <code>:edf_channels</code> column.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called direclty.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L575-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.onda_samples_from_edf_signals" href="#OndaEDF.onda_samples_from_edf_signals"><code>OndaEDF.onda_samples_from_edf_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.onda_samples_from_edf_signals(target::Onda.SamplesInfo, edf_signals,
                                      edf_seconds_per_record; dither_storage=missing)</code></pre><p>Generate an <code>Onda.Samples</code> struct from an iterable of <code>EDF.Signal</code>s, based on the <code>Onda.SamplesInfo</code> in <code>target</code>.  This checks for matching sample rates in the source signals.  If the encoding of <code>target</code> is the same as the encoding in a signal, its encoded (usually <code>Int16</code>) data is copied directly into the <code>Samples</code> data matrix; otherwise it is re-encoded.</p><p>If <code>dither_storage=missing</code> (the default), dither storage is allocated automatically as specified in the docstring for <code>Onda.encode</code>. <code>dither_storage=nothing</code> disables dithering.  See <code>Onda.encode</code>&#39;s docstring for more details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not meant to be called directly, but through  <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a></p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Returned samples are integer-encoded. If these samples are being serialized out (e.g. via <code>Onda.store!</code>) this is not an issue, but if the samples are being immediately analyzed in memory, call <code>Onda.decode</code> to decode them to recover the time-series voltages.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L622-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.promote_encodings" href="#OndaEDF.promote_encodings"><code>OndaEDF.promote_encodings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_encodings(encodings; pick_offset=(_ -&gt; 0.0), pick_resolution=minimum)</code></pre><p>Return a common encoding for input <code>encodings</code>, as a <code>NamedTuple</code> with fields <code>sample_type</code>, <code>sample_offset_in_unit</code>, <code>sample_resolution_in_unit</code>, and <code>sample_rate</code>.  If input encodings&#39; <code>sample_rate</code>s are not all equal, an error is thrown.  If sample rates/offests are not equal, then <code>pick_offset</code> and <code>pick_resolution</code> are used to combine them into a common offset/resolution.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called direclty.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/import_edf.jl#L207-L219">source</a></section></article><h2 id="Export-EDF-from-Onda"><a class="docs-heading-anchor" href="#Export-EDF-from-Onda">Export EDF from Onda</a><a id="Export-EDF-from-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#Export-EDF-from-Onda" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.onda_to_edf" href="#OndaEDF.onda_to_edf"><code>OndaEDF.onda_to_edf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">onda_to_edf(samples::AbstractVector{&lt;:Samples}, annotations=[]; kwargs...)</code></pre><p>Return an <code>EDF.File</code> containing signal data converted from a collection of Onda <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Samples-1"><code>Samples</code></a> and (optionally) annotations from an <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#*.onda.annotations.arrow-1"><code>annotations</code> table</a>.</p><p>Following the Onda v0.5 format, <code>annotations</code> can be any Tables.jl-compatible table (DataFrame, Arrow.Table, NamedTuple of vectors, vector of NamedTuples) which follows the <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#*.onda.annotations.arrow-1">annotation schema</a>.</p><p>Each <code>EDF.Signal</code> in the returned <code>EDF.File</code> corresponds to a channel of an input <code>Onda.Samples</code>.</p><p>The ordering of <code>EDF.Signal</code>s in the output will match the order of the input collection of <code>Samples</code> (and within each channel grouping, the order of the samples&#39; channels).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>EDF signals are encoded as Int16, while Onda allows a range of different sample types, some of which provide considerably more resolution than Int16. During export, re-encoding may be necessary if the encoded Onda samples cannot be represented directly as Int16 values.  In this case, new encoding (resolution and offset) will be chosen based on the minimum and maximum values actually present in each <em>signal</em> in the input Onda Samples.  Thus, it may not always be possible to losslessly round trip Onda-formatted datasets to EDF and back.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/a8e63dd325c1498a6a87126938e262339bb1c54f/src/export_edf.jl#L214-L245">source</a></section></article><h2 id="Deprecations"><a class="docs-heading-anchor" href="#Deprecations">Deprecations</a><a id="Deprecations-1"></a><a class="docs-heading-anchor-permalink" href="#Deprecations" title="Permalink"></a></h2><p>To support deserializing plan tables generated with old versions of OndaEDF + Onda, the following schemas are provided.  These are deprecated and will be removed in a future release.</p><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.PlanV1" href="#OndaEDFSchemas.PlanV1"><code>OndaEDFSchemas.PlanV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version PlanV1 begin
    # EDF.SignalHeader fields
    label::String
    transducer_type::String
    physical_dimension::String
    physical_minimum::Float32
    physical_maximum::Float32
    digital_minimum::Float32
    digital_maximum::Float32
    prefilter::String
    samples_per_record::Int16
    # EDF.FileHeader field
    seconds_per_record::Float64
    # Onda.SignalV1 fields (channels -&gt; channel), may be missing
    recording::Union{UUID,Missing} = passmissing(UUID)
    kind::Union{Missing,AbstractString}
    channel::Union{Missing,AbstractString}
    sample_unit::Union{Missing,AbstractString}
    sample_resolution_in_unit::Union{Missing,Float64}
    sample_offset_in_unit::Union{Missing,Float64}
    sample_type::Union{Missing,AbstractString}
    sample_rate::Union{Missing,Float64}
    # errors, use `nothing` to indicate no error
    error::Union{Nothing,String}
end</code></pre><p>A Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of</p><ul><li>fields from <code>EDF.SignalHeader</code> (all mandatory)</li><li>the <code>seconds_per_record</code> field from <code>EDF.FileHeader</code> (mandatory)</li><li>fields from <code>Onda.SignalV1</code> (optional, may be <code>missing</code> to indicate failed conversion), except for <code>file_path</code></li><li><code>error</code>, which is <code>nothing</code> for a conversion that is or is expected to be successful, and a <code>String</code> describing the source of the error (with backtrace) in the case of a caught error.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.FilePlanV1" href="#OndaEDFSchemas.FilePlanV1"><code>OndaEDFSchemas.FilePlanV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version FilePlanV1 &gt; PlanV1 begin
    edf_signal_index::Int
    onda_signal_index::Int
end</code></pre><p>A Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a <a href="#OndaEDFSchemas.PlanV1"><code>PlanV1</code></a> and additional file-level context:</p><ul><li><code>edf_signal_index</code> gives the index of the <code>signals</code> in the source <code>EDF.File</code> corresponding to this row</li><li><code>onda_signal_index</code> gives the index of the output <code>Onda.Samples</code>.</li></ul><p>Note that while the EDF index does correspond to the actual index in <code>edf.signals</code>, some Onda indices may be skipped in the output, so <code>onda_signal_index</code> is only to indicate order and grouping.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convert-to-onda/">« Converting from EDF</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 January 2024 15:17">Tuesday 30 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · OndaEDF</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OndaEDF</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">OndaEDF</a></li><li><a class="tocitem" href="../convert-to-onda/">Converting from EDF</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Import-EDF-to-Onda"><span>Import EDF to Onda</span></a></li><li><a class="tocitem" href="#Export-EDF-from-Onda"><span>Export EDF from Onda</span></a></li><li><a class="tocitem" href="#Deprecations"><span>Deprecations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Import-EDF-to-Onda"><a class="docs-heading-anchor" href="#Import-EDF-to-Onda">Import EDF to Onda</a><a id="Import-EDF-to-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#Import-EDF-to-Onda" title="Permalink"></a></h2><p>OndaEDF.jl prefers &quot;self-service&quot; import over &quot;automagic&quot;, and provides functionality to extract <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Samples-1"><code>Onda.Samples</code></a> and <a href="#OndaEDFSchemas.EDFAnnotationV1"><code>EDFAnnotationV1</code></a>s (which extend  <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Onda.AnnotationV1"><code>Onda.AnnotationV1</code></a>s) from an <code>EDF.File</code>.  These can be written to disk (with <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Onda.store"><code>Onda.store</code></a> / <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.write"><code>Legolas.write</code></a> or manipulated in memory as desired.</p><h3 id="Import-signal-data-as-Samples"><a class="docs-heading-anchor" href="#Import-signal-data-as-Samples">Import signal data as <code>Samples</code></a><a id="Import-signal-data-as-Samples-1"></a><a class="docs-heading-anchor-permalink" href="#Import-signal-data-as-Samples" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.edf_to_onda_samples" href="#OndaEDF.edf_to_onda_samples"><code>OndaEDF.edf_to_onda_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edf_to_onda_samples(edf::EDF.File, plan_table; validate=true, dither_storage=missing)</code></pre><p>Convert Signals found in an EDF File to <code>Onda.Samples</code> according to the plan specified in <code>plan_table</code> (e.g., as generated by <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>), returning an iterable of the generated <code>Onda.Samples</code> and the plan as actually executed.</p><p>The input plan is transformed by using <a href="#OndaEDF.merge_samples_info"><code>merge_samples_info</code></a> to combine rows with the same <code>:onda_signal_index</code> into a common <code>Onda.SamplesInfo</code>.  Then <a href="#OndaEDF.onda_samples_from_edf_signals"><code>OndaEDF.onda_samples_from_edf_signals</code></a> is used to combine the EDF signals data into a single <code>Onda.Samples</code> per group.</p><p>The <code>label</code> of the original <code>EDF.Signal</code>s are preserved in the <code>:edf_channels</code> field of the resulting <code>SamplesInfo</code>s for each <code>Samples</code> generated.</p><p>Any errors that occur are shown as <code>String</code>s (with backtrace) and inserted into the <code>:error</code> column for the corresponding rows from the plan.</p><p>Samples are returned in the order of <code>:onda_signal_index</code>.  Signals that could not be matched or otherwise caused an error during execution are not returned.</p><p>If <code>validate=true</code> (the default), the plan is validated against the <a href="#OndaEDFSchemas.FilePlanV2"><code>FilePlanV2</code></a> schema, and the signal headers in the <code>EDF.File</code>.</p><p>If <code>dither_storage=missing</code> (the default), dither storage is allocated automatically as specified in the docstring for <code>Onda.encode</code>. <code>dither_storage=nothing</code> disables dithering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L494-L520">source</a></section><section><div><pre><code class="language-none">edf_to_onda_samples(edf::EDF.File; kwargs...)</code></pre><p>Read signals from an <code>EDF.File</code> into a vector of <code>Onda.Samples</code>.  This is a convenience function that first formulates an import plan via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>, and then immediately executes this plan with <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.</p><p>The samples and executed plan are returned; it is <strong>strongly advised</strong> that you review the plan for un-extracted signals (where <code>:sensor_type</code> or <code>:channel</code> is <code>missing</code>) and errors (non-<code>nothing</code> values in <code>:error</code>).</p><p>Collections of <code>EDF.Signal</code>s are mapped as channels to <code>Onda.Samples</code> via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  The caller of this function can control the plan via the <code>labels</code> and <code>units</code> keyword arguments, all of which are forwarded to <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.</p><p><code>EDF.Signal</code> labels that are converted into Onda channel names undergo the following transformations:</p><ul><li>the label is whitespace-stripped, parens-stripped, and lowercased</li><li>trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.) are dropped</li><li>any instance of <code>+</code> is replaced with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>all component names are converted to their &quot;canonical names&quot; when possible (e.g. &quot;m1&quot; in an EEG-matched channel name will be converted to &quot;a1&quot;).</li></ul><p>See the OndaEDF README for additional details regarding EDF formatting expectations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L781-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.plan_edf_to_onda_samples" href="#OndaEDF.plan_edf_to_onda_samples"><code>OndaEDF.plan_edf_to_onda_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_edf_to_onda_samples(header, seconds_per_record; labels=STANDARD_LABELS,
                         units=STANDARD_UNITS)
plan_edf_to_onda_samples(signal::EDF.Signal, args...; kwargs...)</code></pre><p>Formulate a plan for converting an EDF signal into Onda format.  This returns a Tables.jl row with all the columns from the signal header, plus additional columns for the <code>Onda.SamplesInfo</code> for this signal, and the <code>seconds_per_record</code> that is passed in here.</p><p>If no labels match, then the <code>channel</code> and <code>kind</code> columns are <code>missing</code>; the behavior of other <code>SamplesInfo</code> columns is undefined; they are currently set to missing but that may change in future versions.</p><p>Any errors that are thrown in the process will be wrapped as <code>SampleInfoError</code>s and then printed with backtrace to a <code>String</code> in the <code>error</code> column.</p><p><strong>Matching EDF label to Onda labels</strong></p><p>The <code>labels</code> keyword argument determines how Onda <code>channel</code> and signal <code>kind</code> are extracted from the EDF label.</p><p>Labels are specified as an iterable of <code>signal_names =&gt; channel_names</code> pairs. <code>signal_names</code> should be an iterable of signal names, the first of which is the canonical name used as the Onda <code>kind</code>.  Each element of <code>channel_names</code> gives the specification for one channel, which can either be a string, or a <code>canonical_name =&gt; alternates</code> pair.  Occurences of <code>alternates</code> will be replaces with <code>canonical_name</code> in the generated channel label.</p><p>Matching is determined <em>solely</em> by the channel names.  When matching, the signal names are only used to remove signal names occuring as prefixes (e.g., &quot;[ECG] AVL&quot;) before matching channel names.  See <a href="#OndaEDF.match_edf_label"><code>match_edf_label</code></a> for details, and see <code>OndaEDF.STANDARD_LABELS</code> for the default labels.</p><p>As an example, here is (a subset of) the default labels for ECG signals:</p><pre><code class="language-julia">[&quot;ecg&quot;, &quot;ekg&quot;] =&gt; [&quot;i&quot; =&gt; [&quot;1&quot;], &quot;ii&quot; =&gt; [&quot;2&quot;], &quot;iii&quot; =&gt; [&quot;3&quot;],
                   &quot;avl&quot;=&gt; [&quot;ecgl&quot;, &quot;ekgl&quot;, &quot;ecg&quot;, &quot;ekg&quot;, &quot;l&quot;], 
                   &quot;avr&quot;=&gt; [&quot;ekgr&quot;, &quot;ecgr&quot;, &quot;r&quot;], ...]</code></pre><p>Matching is done in the order that <code>labels</code> iterates pairs, and will stop at the first match, with no warning if signals are ambiguous (although this may change in a future version)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L297-L342">source</a></section><section><div><pre><code class="language-none">plan_edf_to_onda_samples(edf::EDF.File;
                         labels=STANDARD_LABELS,
                         units=STANDARD_UNITS,
                         onda_signal_groupby=(:sensor_type, :sample_unit, :sample_rate))</code></pre><p>Formulate a plan for converting an <code>EDF.File</code> to Onda Samples.  This applies <code>plan_edf_to_onda_samples</code> to each individual signal contained in the file, storing <code>edf_signal_index</code> as an additional column.  </p><p>The resulting rows are then passed to <a href="#OndaEDF.plan_edf_to_onda_samples_groups"><code>plan_edf_to_onda_samples_groups</code></a> and grouped according to <code>onda_signal_groupby</code> (by default, the <code>:sensor_type</code>, <code>:sample_unit</code>, and <code>:sample_rate</code> columns), and the group index is added as an additional column in <code>onda_signal_index</code>.</p><p>The resulting plan is returned as a table.  No signal data is actually read from the EDF file; to execute this plan and generate <code>Onda.Samples</code>, use <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.  The index of the EDF signal (after filtering out signals that are not <code>EDF.Signal</code>s, e.g. annotation channels) for each row is stored in the <code>:edf_signal_index</code> column, and the rows are sorted in order of <code>:onda_signal_index</code>, and then by <code>:edf_signal_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L406-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.plan_edf_to_onda_samples_groups" href="#OndaEDF.plan_edf_to_onda_samples_groups"><code>OndaEDF.plan_edf_to_onda_samples_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_edf_to_onda_samples_groups(plan_rows; onda_signal_groupby=(:sensor_type, :sample_unit, :sample_rate))</code></pre><p>Group together <code>plan_rows</code> based on the values of the <code>onda_signal_groupby</code> columns, creating the <code>:onda_signal_index</code> column and promoting the Onda encodings for each group using <a href="#OndaEDF.promote_encodings"><code>OndaEDF.promote_encodings</code></a>.</p><p>If the <code>:edf_signal_index</code> column is not present or otherwise missing, it will be filled in based on the order of the input rows.</p><p>The updated rows are returned, sorted first by the columns named in <code>onda_signal_groupby</code> and second by order of occurrence within the input rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L454-L466">source</a></section></article><h3 id="Import-annotations"><a class="docs-heading-anchor" href="#Import-annotations">Import annotations</a><a id="Import-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Import-annotations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.edf_to_onda_annotations" href="#OndaEDF.edf_to_onda_annotations"><code>OndaEDF.edf_to_onda_annotations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edf_to_onda_annotations(edf::EDF.File, uuid::UUID)</code></pre><p>Extract EDF+ annotations from an <code>EDF.File</code> for recording with ID <code>uuid</code> and return them as a vector of <code>Onda.Annotation</code>s.  Each returned annotation has a  <code>value</code> field that contains the string value of the corresponding EDF+ annotation.</p><p>If no EDF+ annotations are found in <code>edf</code>, then an empty <code>Vector{Annotation}</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L815-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.EDFAnnotationV1" href="#OndaEDFSchemas.EDFAnnotationV1"><code>OndaEDFSchemas.EDFAnnotationV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version EDFAnnotationV1 &gt; AnnotationV1 begin
    value::String
end</code></pre><p>A Legolas-generated record type that represents a single annotation imported from an EDF Annotation signal.  The <code>value</code> field contains the annotation value as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/OndaEDFSchemas.jl/src/OndaEDFSchemas.jl#L170-L178">source</a></section></article><h3 id="Import-plan-table-schemas"><a class="docs-heading-anchor" href="#Import-plan-table-schemas">Import plan table schemas</a><a id="Import-plan-table-schemas-1"></a><a class="docs-heading-anchor-permalink" href="#Import-plan-table-schemas" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.PlanV2" href="#OndaEDFSchemas.PlanV2"><code>OndaEDFSchemas.PlanV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version PlanV2 begin
    # EDF.SignalHeader fields
    label::String
    transducer_type::String
    physical_dimension::String
    physical_minimum::Float32
    physical_maximum::Float32
    digital_minimum::Float32
    digital_maximum::Float32
    prefilter::String
    samples_per_record::Int16
    # EDF.FileHeader field
    seconds_per_record::Float64
    # Onda.SignalV2 fields (channels -&gt; channel), may be missing
    recording::Union{UUID,Missing} = passmissing(UUID)
    sensor_type::Union{Missing,AbstractString}
    sensor_label::Union{Missing,AbstractString}
    channel::Union{Missing,AbstractString}
    sample_unit::Union{Missing,AbstractString}
    sample_resolution_in_unit::Union{Missing,Float64}
    sample_offset_in_unit::Union{Missing,Float64}
    sample_type::Union{Missing,AbstractString}
    sample_rate::Union{Missing,Float64}
    # errors, use `nothing` to indicate no error
    error::Union{Nothing,String}
end</code></pre><p>A Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of</p><ul><li>fields from <code>EDF.SignalHeader</code> (all mandatory)</li><li>the <code>seconds_per_record</code> field from <code>EDF.FileHeader</code> (mandatory)</li><li>fields from <code>Onda.SignalV2</code> (optional, may be <code>missing</code> to indicate failed conversion), except for <code>file_path</code></li><li><code>error</code>, which is <code>nothing</code> for a conversion that is or is expected to be successful, and a <code>String</code> describing the source of the error (with backtrace) in the case of a caught error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/OndaEDFSchemas.jl/src/OndaEDFSchemas.jl#L123-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.FilePlanV2" href="#OndaEDFSchemas.FilePlanV2"><code>OndaEDFSchemas.FilePlanV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version FilePlanV2 &gt; PlanV2 begin
    edf_signal_index::Int
    onda_signal_index::Int
end</code></pre><p>A Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a <a href="#OndaEDFSchemas.PlanV2"><code>PlanV2</code></a> and additional file-level context:</p><ul><li><code>edf_signal_index</code> gives the index of the <code>signals</code> in the source <code>EDF.File</code> corresponding to this row</li><li><code>onda_signal_index</code> gives the index of the output <code>Onda.Samples</code>.</li></ul><p>Note that while the EDF index does correspond to the actual index in <code>edf.signals</code>, some Onda indices may be skipped in the output, so <code>onda_signal_index</code> is only to indicate order and grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/OndaEDFSchemas.jl/src/OndaEDFSchemas.jl#L160-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.write_plan" href="#OndaEDF.write_plan"><code>OndaEDF.write_plan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_plan(io_or_path, plan_table; validate=true, kwargs...)</code></pre><p>Write a plan table to <code>io_or_path</code> using <code>Legolas.write</code>, using the <code>ondaedf.file-plan@1</code> schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/OndaEDF.jl#L24-L29">source</a></section></article><h3 id="Full-service-import"><a class="docs-heading-anchor" href="#Full-service-import">Full-service import</a><a id="Full-service-import-1"></a><a class="docs-heading-anchor-permalink" href="#Full-service-import" title="Permalink"></a></h3><p>For a more &quot;full-service&quot; experience, OndaEDF.jl also provides functionality to extract <code>Onda.Samples</code> and <code>EDFAnnotationV1</code>s and then write them to disk:</p><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.store_edf_as_onda" href="#OndaEDF.store_edf_as_onda"><code>OndaEDF.store_edf_as_onda</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">store_edf_as_onda(edf::EDF.File, onda_dir, recording_uuid::UUID=uuid4();
                  custom_extractors=STANDARD_EXTRACTORS, import_annotations::Bool=true,
                  postprocess_samples=identity,
                  signals_prefix=&quot;edf&quot;, annotations_prefix=signals_prefix)</code></pre><p>Convert an EDF.File to <code>Onda.Samples</code> and <code>Onda.Annotation</code>s, store the samples in <code>$path/samples/</code>, and write the Onda signals and annotations tables to <code>$path/$(signals_prefix).onda.signals.arrow</code> and <code>$path/$(annotations_prefix).onda.annotations.arrow</code>.  The default prefix is &quot;edf&quot;, and if a prefix is provided for signals but not annotations both will use the signals prefix.  The prefixes cannot reference (sub)directories.</p><p>Returns <code>(; recording_uuid, signals, annotations, signals_path, annotations_path, plan)</code>.</p><p>This is a convenience function that first formulates an import plan via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>, and then immediately executes this plan with <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a>.</p><p>The samples and executed plan are returned; it is <strong>strongly advised</strong> that you review the plan for un-extracted signals (where <code>:sensor_type</code> or <code>:channel</code> is <code>missing</code>) and errors (non-<code>nothing</code> values in <code>:error</code>).</p><p>Groups of <code>EDF.Signal</code>s are mapped as channels to <code>Onda.Samples</code> via <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  The caller of this function can control the plan via the <code>labels</code> and <code>units</code> keyword arguments, all of which are forwarded to <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.</p><p><code>EDF.Signal</code> labels that are converted into Onda channel names undergo the following transformations:</p><ul><li>the label is whitespace-stripped, parens-stripped, and lowercased</li><li>trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.) are dropped</li><li>any instance of <code>+</code> is replaced with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>all component names are converted to their &quot;canonical names&quot; when possible (e.g. &quot;3&quot; in an ECG-matched channel name will be converted to &quot;iii&quot;).</li></ul><p>If more control (e.g. preprocessing signal labels) is required, callers should use <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a> and <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a> directly, and <code>Onda.store</code> the resulting samples manually.</p><p>See the OndaEDF README for additional details regarding EDF formatting expectations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L672-L714">source</a></section></article><h3 id="Internal-import-utilities"><a class="docs-heading-anchor" href="#Internal-import-utilities">Internal import utilities</a><a id="Internal-import-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-import-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.match_edf_label" href="#OndaEDF.match_edf_label"><code>OndaEDF.match_edf_label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.match_edf_label(label, signal_names, channel_name, canonical_names)</code></pre><p>Return a normalized label matched from an EDF <code>label</code>.  The purpose of this function is to remove signal names from the label, and to canonicalize the channel name(s) that remain.  So something like &quot;[eCG] avl-REF&quot; will be transformed to &quot;avl&quot; (given <code>signal_names=[&quot;ecg&quot;]</code>, and <code>channel_name=&quot;avl&quot;</code>)</p><p>This returns <code>nothing</code> if <code>channel_name</code> does not match after normalization.</p><p>Canonicalization</p><ul><li>ensures the given label is whitespace-stripped, lowercase, and parens-free</li><li>strips trailing generic EDF references (e.g. &quot;ref&quot;, &quot;ref2&quot;, etc.)</li><li>replaces all references with the appropriate name as specified by <code>canonical_names</code></li><li>replaces <code>+</code> with <code>_plus_</code> and <code>/</code> with <code>_over_</code></li><li>returns the initial reference name (w/o prefix sign, if present) and the entire label; the initial reference name should match the canonical channel name, otherwise the channel extraction will be rejected.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">match_edf_label(&quot;[ekG]  avl-REF&quot;, [&quot;ecg&quot;, &quot;ekg&quot;], &quot;avl&quot;, []) == &quot;avl&quot;
match_edf_label(&quot;ECG 2&quot;, [&quot;ecg&quot;, &quot;ekg&quot;], &quot;ii&quot;, [&quot;ii&quot; =&gt; [&quot;2&quot;, &quot;two&quot;, &quot;ecg2&quot;]]) == &quot;ii&quot;</code></pre><p>See the tests for more examples</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called directly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L81-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.merge_samples_info" href="#OndaEDF.merge_samples_info"><code>OndaEDF.merge_samples_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.merge_samples_info(plan_rows)</code></pre><p>Create a single, merged <code>SamplesInfo</code> from plan rows, such as generated by <a href="#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>.  Encodings are promoted with <code>promote_encodings</code>.</p><p>The input rows must have the same values for <code>:sensor_type</code>, <code>:sample_unit</code>, and <code>:sample_rate</code>; otherwise an <code>ArgumentError</code> is thrown.</p><p>If any of these values is <code>missing</code>, or any row&#39;s <code>:channel</code> value is <code>missing</code>, this returns <code>missing</code> to indicate it is not possible to determine a shared <code>SamplesInfo</code>.</p><p>The original EDF labels are included in the output in the <code>:edf_channels</code> column.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called direclty.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L569-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.onda_samples_from_edf_signals" href="#OndaEDF.onda_samples_from_edf_signals"><code>OndaEDF.onda_samples_from_edf_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OndaEDF.onda_samples_from_edf_signals(target::Onda.SamplesInfo, edf_signals,
                                      edf_seconds_per_record; dither_storage=missing)</code></pre><p>Generate an <code>Onda.Samples</code> struct from an iterable of <code>EDF.Signal</code>s, based on the <code>Onda.SamplesInfo</code> in <code>target</code>.  This checks for matching sample rates in the source signals.  If the encoding of <code>target</code> is the same as the encoding in a signal, its encoded (usually <code>Int16</code>) data is copied directly into the <code>Samples</code> data matrix; otherwise it is re-encoded.</p><p>If <code>dither_storage=missing</code> (the default), dither storage is allocated automatically as specified in the docstring for <code>Onda.encode</code>. <code>dither_storage=nothing</code> disables dithering.  See <code>Onda.encode</code>&#39;s docstring for more details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not meant to be called directly, but through  <a href="#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L616-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.promote_encodings" href="#OndaEDF.promote_encodings"><code>OndaEDF.promote_encodings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_encodings(encodings; pick_offset=(_ -&gt; 0.0), pick_resolution=minimum)</code></pre><p>Return a common encoding for input <code>encodings</code>, as a <code>NamedTuple</code> with fields <code>sample_type</code>, <code>sample_offset_in_unit</code>, <code>sample_resolution_in_unit</code>, and <code>sample_rate</code>.  If input encodings&#39; <code>sample_rate</code>s are not all equal, an error is thrown.  If sample rates/offests are not equal, then <code>pick_offset</code> and <code>pick_resolution</code> are used to combine them into a common offset/resolution.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is an internal function and is not meant to be called direclty.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/import_edf.jl#L207-L219">source</a></section></article><h2 id="Export-EDF-from-Onda"><a class="docs-heading-anchor" href="#Export-EDF-from-Onda">Export EDF from Onda</a><a id="Export-EDF-from-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#Export-EDF-from-Onda" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaEDF.onda_to_edf" href="#OndaEDF.onda_to_edf"><code>OndaEDF.onda_to_edf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">onda_to_edf(samples::AbstractVector{&lt;:Samples}, annotations=[]; kwargs...)</code></pre><p>Return an <code>EDF.File</code> containing signal data converted from a collection of Onda <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Samples-1"><code>Samples</code></a> and (optionally) annotations from an <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#*.onda.annotations.arrow-1"><code>annotations</code> table</a>.</p><p>Following the Onda v0.5 format, <code>annotations</code> can be any Tables.jl-compatible table (DataFrame, Arrow.Table, NamedTuple of vectors, vector of NamedTuples) which follows the <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#*.onda.annotations.arrow-1">annotation schema</a>.</p><p>Each <code>EDF.Signal</code> in the returned <code>EDF.File</code> corresponds to a channel of an input <code>Onda.Samples</code>.</p><p>The ordering of <code>EDF.Signal</code>s in the output will match the order of the input collection of <code>Samples</code> (and within each channel grouping, the order of the samples&#39; channels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/src/export_edf.jl#L134-L153">source</a></section></article><h2 id="Deprecations"><a class="docs-heading-anchor" href="#Deprecations">Deprecations</a><a id="Deprecations-1"></a><a class="docs-heading-anchor-permalink" href="#Deprecations" title="Permalink"></a></h2><p>To support deserializing plan tables generated with old versions of OndaEDF + Onda, the following schemas are provided.  These are deprecated and will be removed in a future release.</p><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.PlanV1" href="#OndaEDFSchemas.PlanV1"><code>OndaEDFSchemas.PlanV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version PlanV1 begin
    # EDF.SignalHeader fields
    label::String
    transducer_type::String
    physical_dimension::String
    physical_minimum::Float32
    physical_maximum::Float32
    digital_minimum::Float32
    digital_maximum::Float32
    prefilter::String
    samples_per_record::Int16
    # EDF.FileHeader field
    seconds_per_record::Float64
    # Onda.SignalV1 fields (channels -&gt; channel), may be missing
    recording::Union{UUID,Missing} = passmissing(UUID)
    kind::Union{Missing,AbstractString}
    channel::Union{Missing,AbstractString}
    sample_unit::Union{Missing,AbstractString}
    sample_resolution_in_unit::Union{Missing,Float64}
    sample_offset_in_unit::Union{Missing,Float64}
    sample_type::Union{Missing,AbstractString}
    sample_rate::Union{Missing,Float64}
    # errors, use `nothing` to indicate no error
    error::Union{Nothing,String}
end</code></pre><p>A Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of</p><ul><li>fields from <code>EDF.SignalHeader</code> (all mandatory)</li><li>the <code>seconds_per_record</code> field from <code>EDF.FileHeader</code> (mandatory)</li><li>fields from <code>Onda.SignalV1</code> (optional, may be <code>missing</code> to indicate failed conversion), except for <code>file_path</code></li><li><code>error</code>, which is <code>nothing</code> for a conversion that is or is expected to be successful, and a <code>String</code> describing the source of the error (with backtrace) in the case of a caught error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/OndaEDFSchemas.jl/src/OndaEDFSchemas.jl#L122-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaEDFSchemas.FilePlanV1" href="#OndaEDFSchemas.FilePlanV1"><code>OndaEDFSchemas.FilePlanV1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version FilePlanV1 &gt; PlanV1 begin
    edf_signal_index::Int
    onda_signal_index::Int
end</code></pre><p>A Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a <a href="#OndaEDFSchemas.PlanV1"><code>PlanV1</code></a> and additional file-level context:</p><ul><li><code>edf_signal_index</code> gives the index of the <code>signals</code> in the source <code>EDF.File</code> corresponding to this row</li><li><code>onda_signal_index</code> gives the index of the output <code>Onda.Samples</code>.</li></ul><p>Note that while the EDF index does correspond to the actual index in <code>edf.signals</code>, some Onda indices may be skipped in the output, so <code>onda_signal_index</code> is only to indicate order and grouping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/d935016a52d45f28e8d9db5815c7d85929b53744/OndaEDFSchemas.jl/src/OndaEDFSchemas.jl#L159-L174">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../convert-to-onda/">« Converting from EDF</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 13 July 2023 21:49">Thursday 13 July 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

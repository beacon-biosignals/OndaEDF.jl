<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Converting from EDF · OndaEDF</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">OndaEDF</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">OndaEDF</a></li><li class="is-active"><a class="tocitem" href>Converting from EDF</a><ul class="internal"><li><a class="tocitem" href="#Basic-workflow"><span>Basic workflow</span></a></li><li><a class="tocitem" href="#Philosophy"><span>Philosophy</span></a></li><li><a class="tocitem" href="#Converting-a-single-EDF-to-Onda"><span>Converting a single EDF to Onda</span></a></li><li><a class="tocitem" href="#Batch-conversion-of-many-EDFs"><span>Batch conversion of many EDFs</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Converting from EDF</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Converting from EDF</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/OndaEDF.jl/blob/master/docs/src/convert-to-onda.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="An-Opinionated-Guide-to-Converting-EDFs-to-Onda"><a class="docs-heading-anchor" href="#An-Opinionated-Guide-to-Converting-EDFs-to-Onda">An Opinionated Guide to Converting EDFs to Onda</a><a id="An-Opinionated-Guide-to-Converting-EDFs-to-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#An-Opinionated-Guide-to-Converting-EDFs-to-Onda" title="Permalink"></a></h1><h2 id="Basic-workflow"><a class="docs-heading-anchor" href="#Basic-workflow">Basic workflow</a><a id="Basic-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-workflow" title="Permalink"></a></h2><p>At a high level, the basic workflow for EDF-to-Onda conversion is iterative:</p><ol><li>Formulate a &quot;plan&quot; which specifies how to convert the metadata associated with each <code>EDF.Signal</code> into Onda metadata (channel names, quantization/encoding parameters, etc.)</li><li>Review the plan, making sure that all necessary <code>EDF.Signal</code>s will be extracted, and that the quantization, sample rate, physical units, etc. are reasonable.</li><li>Revise the plan as needed, repeating steps 1-2 until you&#39;re happy.</li><li>Execute the plan, loading all EDF signal data if necessary and converting into <code>Onda.Samples</code></li><li>Review the executed plan for additional errors or issues, and iterate steps 1-4 as needed.</li></ol><p>In the following sections, we expand on the philosophy behind OndaEDF&#39;s EDF-to-Onda design and present some detailed, opinionated workflows for converting a single EDF and multiple EDFs.</p><h2 id="Philosophy"><a class="docs-heading-anchor" href="#Philosophy">Philosophy</a><a id="Philosophy-1"></a><a class="docs-heading-anchor-permalink" href="#Philosophy" title="Permalink"></a></h2><p>The motivation for separating the planning and execution is threefold.</p><p>First, while there is an <a href="https://www.edfplus.info/specs/index.html">EDF(+) specification</a>,  it&#39;s so commonly violated in so many various ways that an EDF conversion package that <em>requires</em> fully spec-compliant EDFs is of little practical use, but at the same time, anticipating and working around all these possible violations is not practical. Separating planning and execution during EDF-to-Onda conversion reverts more control to the user for how their <em>particular</em> EDF files are handled.</p><p>Second, making the plan a separate intermediate output means that not only can it be reviewed during conversion but can be persisted as a record of how any EDF-derived Onda signals were converted. This kind of provenance information is very useful when investigating issues with a dataset that may crop up long after the initial conversion.</p><p>Third, planning only requires that the <em>headers</em> of the <code>EDF.Signal</code>s be read into memory, thereby separating the iterative part of the conversion process from the expensive, one-time step which requires <em>all</em> the signal data be read into memory. This enables workflows that would be impractical otherwise, like planning bulk conversion of thousands of EDFs at once. When dealing with large, messy datasets, we have found that metadata issues are both likely to occur and likely to be <em>different</em> across individual EDFs. This makes normalizing the EDF metadata one file at a time extremely tedious, since the metadata issues encountered in a single file may not be representative of the rest of the dataset. Thus, in practice it&#39;s better to deal with EDF metadata conversion in <em>bulk</em>, and the plan-then-execute workflow enables users to deal with these issues all at once, save out the plan, and then distribute the actual conversion work to as many workers as necessary to execute it in a reasonable timeframe.</p><h2 id="Converting-a-single-EDF-to-Onda"><a class="docs-heading-anchor" href="#Converting-a-single-EDF-to-Onda">Converting a single EDF to Onda</a><a id="Converting-a-single-EDF-to-Onda-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-a-single-EDF-to-Onda" title="Permalink"></a></h2><p>The following steps assume you have read an EDF file into memory with <code>EDF.read</code> or otherwise created an <code>EDF.File</code>. After the detailed workflow for converting a single EDF file to Onda format, we&#39;ll discuss how to handle batches of EDF files.</p><h3 id="Generate-a-plan"><a class="docs-heading-anchor" href="#Generate-a-plan">Generate a plan</a><a id="Generate-a-plan-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-a-plan" title="Permalink"></a></h3><p>This is straightforward, using <a href="../api/#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>. As outlined in the documentation for <a href="../api/#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>, a &quot;plan&quot; is a table with one row per <code>EDF.Signal</code>, which contains all the fields from the signal&#39;s header as well as the fields of the <code>Onda.SamplesInfoV2</code> that will be generated when the plan is executed (with the caveat that the <code>:channels</code> field is called <code>:channel</code> to indicate that it corresponds to a single channel in the output). It also contains a few additional fields for defining the mapping between EDF and Onda signal indices, as well as a field to capture any errors thrown during planning (or, more likely, during execution of the plan):</p><ul><li><code>:edf_signal_index</code>, the 1-based numerical index of the source signal in <code>edf.signals</code></li><li><code>:onda_signal_index</code>, the ordinal index of the resulting samples (not necessarily the index into <code>samples</code>, since some groups might be skipped)</li><li><code>:error</code>, any errors that were caught during planning and/or execution.</li></ul><h3 id="Review-the-plan."><a class="docs-heading-anchor" href="#Review-the-plan.">Review the plan.</a><a id="Review-the-plan.-1"></a><a class="docs-heading-anchor-permalink" href="#Review-the-plan." title="Permalink"></a></h3><p>Check for EDF signals whose <code>label</code> or <code>physical_dimension</code> could not be matched using the standard OndaEDF labels and units, as indicated by <code>missing</code> values in the <code>channel</code>/<code>sensor_type</code> (for un-matched <code>label</code>) or <code>sample_unit</code> (for un-matched <code>physical_dimension</code>). It&#39;s also a good idea at this point to review the other EDF signal header fields, and how they will be converted to Onda (especially the sample unit, resolution and offset, which correspond to the physical/digital minimum/maximum from the EDF signal header.) It&#39;s harder to fix these issues with the numerical signal header fields as they usually point to issues with how the data was encoded into an EDF initially. However, it&#39;s still better to detect and document any issues with the underlying EDF data at this stage to prevent nasty surprises down the road.</p><h3 id="Revise-the-plan"><a class="docs-heading-anchor" href="#Revise-the-plan">Revise the plan</a><a id="Revise-the-plan-1"></a><a class="docs-heading-anchor-permalink" href="#Revise-the-plan" title="Permalink"></a></h3><p>If there are EDF signals with un-matched <code>label</code> or <code>physical_dimension</code>, you have a few options. We recommend you consider them in roughly this order.</p><h4 id="Skip-them"><a class="docs-heading-anchor" href="#Skip-them">Skip them</a><a id="Skip-them-1"></a><a class="docs-heading-anchor-permalink" href="#Skip-them" title="Permalink"></a></h4><p>The first option to consider is to simply ignore these signals; not all signals are necessarily required for downstream use, and converting each and every signal in an EDF may be more work than is justified!</p><h4 id="Provide-custom-labels-and-units"><a class="docs-heading-anchor" href="#Provide-custom-labels-and-units">Provide custom labels and units</a><a id="Provide-custom-labels-and-units-1"></a><a class="docs-heading-anchor-permalink" href="#Provide-custom-labels-and-units" title="Permalink"></a></h4><p>The second option you have is to provide custom <code>labels=</code> and <code>units=</code> keyword arguments to <a href="../api/#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a>. For unambiguous, <a href="https://www.edfplus.info/specs/edftexts.html#label_physidim">spec-compliant</a> <code>label</code>s and <code>physical_dimension</code>s, it&#39;s generally possible to create custom <code>label=</code> or <code>unit=</code> specifications to match them.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Custom labels should be specified as <em>lowercase</em>, without reference, and without the sensor type prefix. So to match a label like <code>&quot;EEG R1-Ref&quot;</code>, use a label like <code>&quot;eeg&quot; =&gt; [&quot;r1&quot;]</code>, and not <code>&quot;EEG&quot; =&gt; [&quot;R1&quot;]</code> or <code>&quot;eeg&quot; =&gt; [&quot;r1-ref&quot;]</code>. See the documentation for <a href="../api/#OndaEDF.plan_edf_to_onda_samples"><code>plan_edf_to_onda_samples</code></a> for more details, and the internal <a href="../api/#OndaEDF.match_edf_label"><code>OndaEDF.match_edf_label</code></a> for low-level details of how labels are matched.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Sometimes EDF <code>label</code>s are ambiguous and can be matched by multiple different OndaEDF <code>label=</code> specifications. Matching is greedy, in that the first label specification that matches is used regardless of any other possible matches, so you should add your custom labels to the end of an existing set, as in</p><pre><code class="language-julia">my_labels = collect(pairs(OndaEDF.STANDARD_LABELS))
push!(my_labels, [&quot;eog&quot;] =&gt; [&quot;left&quot; =&gt; &quot;eyeleft&quot;, &quot;right&quot; =&gt; &quot;eyeright&quot;])</code></pre><p>When using custom labels, make sure that they haven&#39;t accidentally changed how other <code>label</code>s are matched by reviewing the plan for any unintended changes.</p></div></div><h4 id="Preprocess-signal-headers"><a class="docs-heading-anchor" href="#Preprocess-signal-headers">Preprocess signal headers</a><a id="Preprocess-signal-headers-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocess-signal-headers" title="Permalink"></a></h4><p>The third option, for signals that <em>must</em> be converted and cannot be handled with custom labels (without undue hassle) is to pre-process the signal headers before generating the plan. While the canonical input to <code>plan_edf_to_onda_samples</code> is an <code>EDF.File</code>, the header-matching logic operates fundamentally one signal header at a time. Moreover, it does not actually require that the input <em>be</em> an <code>EDF.SignalHeader</code>, only that it have the same <em>fields</em> as an <code>EDF.SignalHeader</code>. This design decision is meant to support workflows where the signal headers cannot for some reason be processed as-is due to corrupt/malformed strings, labels that cannot be matched using the OndaEDF matching algorithm, or any other reason.</p><p>For example, we&#39;ve encountered EDFs in the wild where the <code>transducer_type</code> and <code>label</code> fields are switched, and must be switched back before planning:</p><pre><code class="language-julia">edf = EDF.File(my_edf_file_path)

function corrected_header(signal::EDF.Signal)
    header = signal.header
    return Tables.rowmerge(header; 
                           label=header.transducer_type, 
                           transducer_type=header.label)
end

plans = map(plan_edf_to_onda_samples ∘ corrected_header, edf.signals)
new_plan = plan_edf_to_onda_samples_groups(plans)</code></pre><p>Note that an additional step of <code>plan_edf_to_onda_samples_groups</code> is required after planning the individual signals. This is due to the fact that EDF is a &quot;single channel&quot; format, where each signal is only a single channel, while Onda is a &quot;multichannel&quot; format where a signal can have mmultiple channels as long as the sampling rate, quantization, and other metadata are consistent. Normally, calling <code>plan_edf_to_onda_samples</code> with an <code>EDF.File</code> will do this grouping for you, but when planning individually pre-processed signal headers, we have to do it ourselves at the end.</p><h4 id="Modify-the-generated-plan"><a class="docs-heading-anchor" href="#Modify-the-generated-plan">Modify the generated plan</a><a id="Modify-the-generated-plan-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-the-generated-plan" title="Permalink"></a></h4><p>The fourth and final option is to modify the generated plan itself. This is the least preferred method because it removes a number of safeguards that OndaEDF provides as part of the planning process, but it&#39;s also the most flexible in that it enables completely hand-crafted conversion. Here are a few examples, motivated by EDFs we have seen in the wild.</p><p>Some EEG signals have the physical units set to millivolts, but biologically generated EEG signals are generally on the order of <em>microvolts</em>. During import, you want to correct this by adjusting the encoding settings used by Onda to store samples, by scaling the sample offset and resolution by 1000 and setting the physical units. This can be accomplished by modifying the rows of the plan like so:</p><pre><code class="language-julia">edf = EDF.File(my_edf_file_path)
plans = plan_edf_to_onda_samples(edf; label=my_labels)

function fix_millivolts(plan)
    if plan.sample_unit == &quot;millivolt&quot; &amp;&amp; plan.sensor_type == &quot;eeg&quot;
        sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000
        sample_offset_in_unit = plan.sample_offset_in_unit * 1000
        return Tables.rowmerge(plan; sample_unit=&quot;microvolt&quot;,
                               sample_resolution_in_unit,
                               sample_offset_in_unit)
    else
        return plan
    end
end

new_plan = map(fix_millivolts, Tables.rows(plans))</code></pre><p>As another, similar example, sometimes EMG channels get recorded with different physical units. In such a case, OndaEDF cannot merge these channels and will create multiple separate <code>Samples</code> objects which each have <code>sensor_type = &quot;emg&quot;</code>. This can be corrected in a similar way, for exmaple by converting millivolts to microvolts (adjusting of course depending on the nature of your dataset) and re-grouping into Onda samples:</p><pre><code class="language-julia">edf = EDF.File(my_edf_file_path)
plans = plan_edf_to_onda_samples(edf; label=my_labels)

function fix_emg(plan)
    if plan.sensor_type == &quot;emg&quot;
        if plan.sample_unit == &quot;millivolt&quot;
            sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000
            sample_offset_in_unit = plan.sample_offset_in_unit * 1000
            plan = Tables.rowmerge(plan; sample_unit=&quot;microvolt&quot;,
                                   sample_resolution_in_unit,
                                   sample_offset_in_unit)
        end
        return plan
    else
        return plan
    end
end

new_plan = map(fix_emg, Tables.rows(plans))
# re-compute the grouping of EDF signals into Onda signals:
new_plan = plan_edf_to_onda_samples_groups(new_plan)</code></pre><h3 id="Execute-the-plan"><a class="docs-heading-anchor" href="#Execute-the-plan">Execute the plan</a><a id="Execute-the-plan-1"></a><a class="docs-heading-anchor-permalink" href="#Execute-the-plan" title="Permalink"></a></h3><p>Once the plan has been reviewed and deemed satisfactory, execute the plan to generate <code>Onda.Samples</code> and an &quot;executed plan&quot; record. This is accomplished with the <a href="../api/#OndaEDF.edf_to_onda_samples"><code>edf_to_onda_samples</code></a> function, which takes an <code>EDF.File</code> and a plan as input, and returns a vector of <code>Onda.Samples</code> and the plan as executed. The executed plan may differ from the input plan. Most notably, if any errors were encountered during execution, they will be caught and the error and stacktrace will be stored as strings in the <code>error</code> field. It is important to review the executed plan a final time to ensure everything was converted as expected and no unexpected errors were encountered. If any errors <em>were</em> encountered, you may need to iterate further.</p><h3 id="Store-the-output"><a class="docs-heading-anchor" href="#Store-the-output">Store the output</a><a id="Store-the-output-1"></a><a class="docs-heading-anchor-permalink" href="#Store-the-output" title="Permalink"></a></h3><p>The final step is to store both the <code>Onda.Samples</code> and the executed plan in some persistent storage. For storing <code>Onda.Samples</code>, see <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Onda.store"><code>Onda.store</code></a>, which supports serializing LPCM-encoded samples to <a href="https://beacon-biosignals.github.io/Onda.jl/stable/#Support-For-Generic-Path-Like-Types">any &quot;path-like&quot; type</a> (i.e., anything that provides a method for <code>write</code>). For storing the plan, use <a href="../api/#OndaEDF.write_plan"><code>OndaEDF.write_plan</code></a> (or <code>Legolas.write(file_path, plan, FilePlanV2SchemaVersion())</code> (see the documentation for <a href="https://beacon-biosignals.github.io/Legolas.jl/stable/#Legolas.write"><code>Legolas.write</code></a> and <a href="@ref"><code>FilePlanV2</code></a>.</p><h2 id="Batch-conversion-of-many-EDFs"><a class="docs-heading-anchor" href="#Batch-conversion-of-many-EDFs">Batch conversion of many EDFs</a><a id="Batch-conversion-of-many-EDFs-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-conversion-of-many-EDFs" title="Permalink"></a></h2><p>The workflow for bulk conversion of multiple EDFs is similar to the workflow for converting a single EDF. The major difference is that the &quot;planning&quot; steps can be conducted in bulk, while the &quot;execution&quot; steps (generally) need to be conducted one at a time, either serially or distributed across multiple workers. As discussed above, the planning stage requires only a few KB from the EDF file/signal headers, facilitating rapid plan-review-revise iteration of even fairly large collections of EDFs (10,000+).</p><h3 id="Planning-multiple-EDFs"><a class="docs-heading-anchor" href="#Planning-multiple-EDFs">Planning multiple EDFs</a><a id="Planning-multiple-EDFs-1"></a><a class="docs-heading-anchor-permalink" href="#Planning-multiple-EDFs" title="Permalink"></a></h3><p>The main factor to consider when planning conversion of a large batch of EDF files is that planning requires only the (small number) of header bytes, even for very large EDF files. Thus, the first step is to read the file headers into memory without reading the signal data itself (which for more than a few EDF files will not usually fit into memory due to the large amount of signal data found in EDF files).</p><h4 id="Reading-headers-from-local-filesystem"><a class="docs-heading-anchor" href="#Reading-headers-from-local-filesystem">Reading headers from local filesystem</a><a id="Reading-headers-from-local-filesystem-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-headers-from-local-filesystem" title="Permalink"></a></h4><p>For EDF files stored on a normal filesystem, the <code>EDF.File</code> constructor will by default create a &quot;header-only&quot; <code>EDF.File</code>, so multiple files&#39; headers can be read like</p><pre><code class="language-julia">files = map(edf_paths) do path
    open(EDF.File, path, &quot;r&quot;)
end</code></pre><h4 id="Reading-headers-from-S3"><a class="docs-heading-anchor" href="#Reading-headers-from-S3">Reading headers from S3</a><a id="Reading-headers-from-S3-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-headers-from-S3" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This section may become obsolete in a future version of EDF.jl which uses the <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Weak-dependencies">conditional dependency</a> functionality available from Julia 1.9+ to provide tighter integration with AWSS3.jl.</p></div></div><p>Unfortunately, <code>open(path::S3Path)</code> will fetch the entire contents of the object stored at <code>path</code>, so we need to be a bit clever to read <em>only</em> header bytes from an S3 file, especially given that the number of bytes we need to read depends on the number of signals. The following is an example of one technique for reading EDF file and signal headers from S3:</p><pre><code class="language-julia">function EDF.read_file_header(path::S3Path)
    bytes = s3_get(path.bucket, path.key; byte_range=1:256)
    buffer = IOBuffer(bytes)
    return EDF.read_file_header(buffer)
end

function EDF.File(path::S3Path)
    _, n_signals = EDF.read_file_header(path)
    bytes = s3_get(path.bucket, path.key; byte_range=1:(256 * (n_signals + 1)))
    return EDF.File(IOBuffer(bytes))
end

# use asyncmap because this is mostly bound by request roundtrip latency
files = asyncmap(EDF.File, edf_paths)</code></pre><h4 id="Concatenating-plans-into-one-big-table"><a class="docs-heading-anchor" href="#Concatenating-plans-into-one-big-table">Concatenating plans into one big table</a><a id="Concatenating-plans-into-one-big-table-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenating-plans-into-one-big-table" title="Permalink"></a></h4><p>When doing bulk review of plans, it&#39;s generally helpful to have the individual files&#39; plans concatenated into a single large table. It&#39;s important to keep track of which plan rows corresopnd to which input file, which can be accomplished via something like this:</p><pre><code class="language-julia"># create a UUID namespace to make recording ID generation idempotent
const NAMESPACE = UUID(...)
function plan_all(edf_paths, files; kwargs...)
    plans = mapreduce(vcat, edf_paths, files) do origin_uri, edf
        plan = plan_edf_to_onda_samples(edf; kwargs...)
        plan = DataFrame(plan)
        # make sure this is the same every time this function is re-run!
        recording = uuid5(NAMESPACE, string(origin_uri))
        return insertcols!(plan, 
                           :origin_uri =&gt; origin_uri,
                           :recording =&gt; recording)
    end
end</code></pre><h3 id="Review-and-revise-the-plans"><a class="docs-heading-anchor" href="#Review-and-revise-the-plans">Review and revise the plans</a><a id="Review-and-revise-the-plans-1"></a><a class="docs-heading-anchor-permalink" href="#Review-and-revise-the-plans" title="Permalink"></a></h3><p>This &quot;bulk plan&quot; table can then be reviewed in bulk, looking for patterns in which <code>label</code>s are not matched, physical units associated with each <code>sensor_type</code>, etc. At a minimum, we find it useful to print some basic counts:</p><pre><code class="language-julia">plans = plan_all(...)
# helper function to tally rows per group
tally(df, g, agg...=nrow =&gt; :count) = combine(groupby(df, g), agg...)
unmatched_labels = filter(:channel =&gt; ismissing, plans)
@info &quot;unmatched labels:&quot; tally(unmatched_labels, :label)

unmatched_units = filter(:sample_unit =&gt; ismissing, plans)
@info &quot;unmatched labels:&quot; tally(unmatched_units, :physical_dimension)

matched = subset(plans, :channel =&gt; ByRow(!ismissing), :sample_unit =&gt; ByRow(!ismissing))
@info &quot;matched sensor types/channels:&quot; tally(matched, [:sensor_type, :channel, :sample_unit])</code></pre><p>Reviewing these summaries is a good first step when revising the plans. The revision process is basically the same as with a single EDF: update the <code>labels=</code> and <code>units=</code> as needed to capture any un-matched EDF signals, and failing that, preprocess the headers/postprocess the plan. Note that if it is necessary to run <a href="../api/#OndaEDF.plan_edf_to_onda_samples_groups"><code>plan_edf_to_onda_samples_groups</code></a>, this must be done one file at a time, using something like this to preserve the recording-level keys created above:</p><pre><code class="language-julia">new_plans = combine(groupby(plans, [:recording, :origin_uri])) do plan
    new_plan = plan_edf_to_onda_samples_groups(Tables.rows(plan))
    return DataFrame(new_plan)
end</code></pre><h3 id="Executing-bulk-plans-and-storing-generated-samples"><a class="docs-heading-anchor" href="#Executing-bulk-plans-and-storing-generated-samples">Executing bulk plans and storing generated samples</a><a id="Executing-bulk-plans-and-storing-generated-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-bulk-plans-and-storing-generated-samples" title="Permalink"></a></h3><p>The last step, as with single EDF conversion, is to execute the plans. Given that this requires loading signal data into memory, it&#39;s generally necessary to do this one recording at a time, either serially on a single process or using <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">multiprocessing</a> to distribute work over different processes or even machines. A complete introduction to multiprocessing in Julia is outside the scope of this guide, but we offer a few pointers in the hope that we can help avoid common pitfalls.</p><p>First, it&#39;s generally a good idea to create a function that accepts one recording&#39;s plan, EDF file path, and recording ID (or generally any additional metadata that is required to create a persistent record), which will execute the plan and persistently store the resulting samples and executed plan. This function then may return either the generated <code>Onda.SignalV2</code> and <code>OndaEDF.FilePlanV2</code> tables for the completed recording, or pointers to where these are stored. This way, the memory pressure involved in loading an entire EDF&#39;s signal data is confined to function scope which makes it slightly easier for Julia&#39;s garbage collector.</p><p>Second, a <em>separate</em> function should handle coordinating these individual jobs and then collecting these results into the ultimate aggregate signal and plan tables, and then persistently storing <em>those</em> to a final destination.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« OndaEDF</a><a class="docs-footer-nextpage" href="../api/">API Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 17 October 2023 12:56">Tuesday 17 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

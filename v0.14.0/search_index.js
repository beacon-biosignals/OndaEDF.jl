var documenterSearchIndex = {"docs":
[{"location":"convert-to-onda/#An-Opinionated-Guide-to-Converting-EDFs-to-Onda","page":"Converting from EDF","title":"An Opinionated Guide to Converting EDFs to Onda","text":"","category":"section"},{"location":"convert-to-onda/#Basic-workflow","page":"Converting from EDF","title":"Basic workflow","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"At a high level, the basic workflow for EDF-to-Onda conversion is iterative:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Formulate a \"plan\" which specifies how to convert the metadata associated with each EDF.Signal into Onda metadata (channel names, quantization/encoding parameters, etc.)\nReview the plan, making sure that all necessary EDF.Signals will be extracted, and that the quantization, sample rate, physical units, etc. are reasonable.\nRevise the plan as needed, repeating steps 1-2 until you're happy.\nExecute the plan, loading all EDF signal data if necessary and converting into Onda.Samples\nReview the executed plan for additional errors or issues, and iterate steps 1-4 as needed.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"In the following sections, we expand on the philosophy behind OndaEDF's EDF-to-Onda design and present some detailed, opinionated workflows for converting a single EDF and multiple EDFs.","category":"page"},{"location":"convert-to-onda/#Philosophy","page":"Converting from EDF","title":"Philosophy","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The motivation for separating the planning and execution is threefold.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"First, while there is an EDF(+) specification,  it's so commonly violated in so many various ways that an EDF conversion package that requires fully spec-compliant EDFs is of little practical use, but at the same time, anticipating and working around all these possible violations is not practical. Separating planning and execution during EDF-to-Onda conversion reverts more control to the user for how their particular EDF files are handled.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Second, making the plan a separate intermediate output means that not only can it be reviewed during conversion but can be persisted as a record of how any EDF-derived Onda signals were converted. This kind of provenance information is very useful when investigating issues with a dataset that may crop up long after the initial conversion.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Third, planning only requires that the headers of the EDF.Signals be read into memory, thereby separating the iterative part of the conversion process from the expensive, one-time step which requires all the signal data be read into memory. This enables workflows that would be impractical otherwise, like planning bulk conversion of thousands of EDFs at once. When dealing with large, messy datasets, we have found that metadata issues are both likely to occur and likely to be different across individual EDFs. This makes normalizing the EDF metadata one file at a time extremely tedious, since the metadata issues encountered in a single file may not be representative of the rest of the dataset. Thus, in practice it's better to deal with EDF metadata conversion in bulk, and the plan-then-execute workflow enables users to deal with these issues all at once, save out the plan, and then distribute the actual conversion work to as many workers as necessary to execute it in a reasonable timeframe.","category":"page"},{"location":"convert-to-onda/#Converting-a-single-EDF-to-Onda","page":"Converting from EDF","title":"Converting a single EDF to Onda","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The following steps assume you have read an EDF file into memory with EDF.read or otherwise created an EDF.File. After the detailed workflow for converting a single EDF file to Onda format, we'll discuss how to handle batches of EDF files.","category":"page"},{"location":"convert-to-onda/#Generate-a-plan","page":"Converting from EDF","title":"Generate a plan","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"This is straightforward, using plan_edf_to_onda_samples. As outlined in the documentation for plan_edf_to_onda_samples, a \"plan\" is a table with one row per EDF.Signal, which contains all the fields from the signal's header as well as the fields of the Onda.SamplesInfoV2 that will be generated when the plan is executed (with the caveat that the :channels field is called :channel to indicate that it corresponds to a single channel in the output). It also contains a few additional fields for defining the mapping between EDF and Onda signal indices, as well as a field to capture any errors thrown during planning (or, more likely, during execution of the plan):","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":":edf_signal_index, the 1-based numerical index of the source signal in edf.signals.\n:sensor_label, label that is unique within this EDF file for this group of channels (may be missing).\n:recording, an optional UUID of the recording procedure these signals should be associated with.\n:error, any errors that were caught during planning and/or execution.","category":"page"},{"location":"convert-to-onda/#Review-the-plan.","page":"Converting from EDF","title":"Review the plan.","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Check for EDF signals whose label or physical_dimension could not be matched using the standard OndaEDF labels and units, as indicated by missing values in the channel/sensor_type (for un-matched label) or sample_unit (for un-matched physical_dimension). It's also a good idea at this point to review the other EDF signal header fields, and how they will be converted to Onda (especially the sample unit, resolution and offset, which correspond to the physical/digital minimum/maximum from the EDF signal header.) It's harder to fix these issues with the numerical signal header fields as they usually point to issues with how the data was encoded into an EDF initially. However, it's still better to detect and document any issues with the underlying EDF data at this stage to prevent nasty surprises down the road.","category":"page"},{"location":"convert-to-onda/#Revise-the-plan","page":"Converting from EDF","title":"Revise the plan","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"If there are EDF signals with un-matched label or physical_dimension, you have a few options. We recommend you consider them in roughly this order.","category":"page"},{"location":"convert-to-onda/#Skip-them","page":"Converting from EDF","title":"Skip them","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The first option to consider is to simply ignore these signals; not all signals are necessarily required for downstream use, and converting each and every signal in an EDF may be more work than is justified!","category":"page"},{"location":"convert-to-onda/#Provide-custom-labels-and-units","page":"Converting from EDF","title":"Provide custom labels and units","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The second option you have is to provide custom labels= and units= keyword arguments to plan_edf_to_onda_samples. For unambiguous, spec-compliant labels and physical_dimensions, it's generally possible to create custom label= or unit= specifications to match them.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"note: Note\nCustom labels should be specified as lowercase, without reference, and without the sensor type prefix. So to match a label like \"EEG R1-Ref\", use a label like \"eeg\" => [\"r1\"], and not \"EEG\" => [\"R1\"] or \"eeg\" => [\"r1-ref\"]. See the documentation for plan_edf_to_onda_samples for more details, and the internal OndaEDF.match_edf_label for low-level details of how labels are matched.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"warning: Warning\nSometimes EDF labels are ambiguous and can be matched by multiple different OndaEDF label= specifications. Matching is greedy, in that the first label specification that matches is used regardless of any other possible matches, so you should add your custom labels to the end of an existing set, as inmy_labels = collect(pairs(OndaEDF.STANDARD_LABELS))\npush!(my_labels, [\"eog\"] => [\"left\" => \"eyeleft\", \"right\" => \"eyeright\"])When using custom labels, make sure that they haven't accidentally changed how other labels are matched by reviewing the plan for any unintended changes.","category":"page"},{"location":"convert-to-onda/#Example:-non-EDF-compliant-label-with-channel-followed-by-signal-type","page":"Converting from EDF","title":"Example: non-EDF+-compliant label with channel followed by signal type","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"OndaEDF will be confused by a label like CHIN EMG using the default labels.  This label does not conform to the EDF+ specification for labels and physical dimensions, which","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"consists of three components, from left to right:Type of signal (for example EEG).\nA space.\nSpecification of the sensor (for example Fpz-Cz).","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"To match this kind of label, we can use a custom label specification like so:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"chin_label = [\"emg\", \"chin\"] => [\"chin\" => [\"emg\"]]\nmy_labels = push!(collect(pairs(OndaEDF.STANDARD_LABELS)), chin_label)\nplan = plan_edf_to_onda_samples(edf; labels=my_labels)","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"To break this label specification down:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"[\"emg\", \"chin\"]: indicates that this specification is for sensor_type of \"emg\", for which \"chin\" is accepted as a non-canonical alternative.\n[\"chin\" => [\"emg\"]] specifies that there's one possible channel for this sensor type, whose canonical label (used in the output) is \"chin\", but for which an alternative of \"emg\" is accepted.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"This essentially tricks OndaEDF into treating CHIN EMG as sensor type of \"CHIN (alternative for sensor type of EMG), and channel label \"EMG (alternative way to specify CHIN)\".  For more details on how this matching is carried out, see plan_edf_to_onda_samples and the internal OndaEDF.match_edf_label.","category":"page"},{"location":"convert-to-onda/#Preprocess-signal-headers","page":"Converting from EDF","title":"Preprocess signal headers","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The third option, for signals that must be converted and cannot be handled with custom labels (without undue hassle) is to pre-process the signal headers before generating the plan. While the canonical input to plan_edf_to_onda_samples is an EDF.File, the header-matching logic operates fundamentally one signal header at a time. Moreover, it does not actually require that the input be an EDF.SignalHeader, only that it have the same fields as an EDF.SignalHeader. This design decision is meant to support workflows where the signal headers cannot for some reason be processed as-is due to corrupt/malformed strings, labels that cannot be matched using the OndaEDF matching algorithm, or any other reason.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"For example, we've encountered EDFs in the wild where the transducer_type and label fields are switched, and must be switched back before planning:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"edf = EDF.File(my_edf_file_path)\n\nfunction corrected_header(signal::EDF.Signal)\n    header = signal.header\n    return Tables.rowmerge(header;\n                           label=header.transducer_type,\n                           transducer_type=header.label)\nend\n\nplans = map(plan_edf_to_onda_samples âˆ˜ corrected_header, edf.signals)\nnew_plan = plan_edf_to_onda_samples_groups(plans)","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Note that an additional step of plan_edf_to_onda_samples_groups is required after planning the individual signals. This is due to the fact that EDF is a \"single channel\" format, where each signal is only a single channel, while Onda is a \"multichannel\" format where a signal can have mmultiple channels as long as the sampling rate, quantization, and other metadata are consistent. Normally, calling plan_edf_to_onda_samples with an EDF.File will do this grouping for you, but when planning individually pre-processed signal headers, we have to do it ourselves at the end.","category":"page"},{"location":"convert-to-onda/#Modify-the-generated-plan","page":"Converting from EDF","title":"Modify the generated plan","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The fourth and final option is to modify the generated plan itself. This is the least preferred method because it removes a number of safeguards that OndaEDF provides as part of the planning process, but it's also the most flexible in that it enables completely hand-crafted conversion. Here are a few examples, motivated by EDFs we have seen in the wild.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Some EEG signals have the physical units set to millivolts, but biologically generated EEG signals are generally on the order of microvolts. During import, you want to correct this by adjusting the encoding settings used by Onda to store samples, by scaling the sample offset and resolution by 1000 and setting the physical units. This can be accomplished by modifying the rows of the plan like so:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"edf = EDF.File(my_edf_file_path)\nplans = plan_edf_to_onda_samples(edf; label=my_labels)\n\nfunction fix_millivolts(plan)\n    if plan.sample_unit == \"millivolt\" && plan.sensor_type == \"eeg\"\n        sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000\n        sample_offset_in_unit = plan.sample_offset_in_unit * 1000\n        return Tables.rowmerge(plan; sample_unit=\"microvolt\",\n                               sample_resolution_in_unit,\n                               sample_offset_in_unit)\n    else\n        return plan\n    end\nend\n\nnew_plan = map(fix_millivolts, Tables.rows(plans))","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"As another, similar example, sometimes EMG channels get recorded with different physical units. In such a case, OndaEDF cannot merge these channels and will create multiple separate Samples objects which each have sensor_type = \"emg\". This can be corrected in a similar way, for exmaple by converting millivolts to microvolts (adjusting of course depending on the nature of your dataset) and re-grouping into Onda samples:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"edf = EDF.File(my_edf_file_path)\nplans = plan_edf_to_onda_samples(edf; label=my_labels)\n\nfunction fix_emg(plan)\n    if plan.sensor_type == \"emg\"\n        if plan.sample_unit == \"millivolt\"\n            sample_resolution_in_unit = plan.sample_resolution_in_unit * 1000\n            sample_offset_in_unit = plan.sample_offset_in_unit * 1000\n            plan = Tables.rowmerge(plan; sample_unit=\"microvolt\",\n                                   sample_resolution_in_unit,\n                                   sample_offset_in_unit)\n        end\n        return plan\n    else\n        return plan\n    end\nend\n\nnew_plan = map(fix_emg, Tables.rows(plans))\n# re-compute the grouping of EDF signals into Onda signals:\nnew_plan = plan_edf_to_onda_samples_groups(new_plan)","category":"page"},{"location":"convert-to-onda/#Execute-the-plan","page":"Converting from EDF","title":"Execute the plan","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Once the plan has been reviewed and deemed satisfactory, execute the plan to generate Onda.Samples and an \"executed plan\" record. This is accomplished with the edf_to_onda_samples function, which takes an EDF.File and a plan as input, and returns a Vector{ConvertedSamples}. For each sensor_label in the plan, the corresponding ConvertedSamples captures the plan rows, the resulting Onda.Samples, and the sensor_label.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"It is important to review the converted samples a final time to ensure everything was converted as expected and no unexpected errors were encountered. First, check for any converted samples with missing values in the samples field. These indicated that conversion of these plan rows failed for some reason, either because the EDF signal metadata could not be matched with appropriate Onda metadata or because of a runtime error during conversion. If any errors were encountered during execution, they will be caught and the error and stacktrace will be stored as strings in the error field. If any errors were encountered, you may need to iterate further.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Second, check the combined plan as executed, which can be recovered via OndaEDF.get_plan(::Vector{ConvertedSamples}), and may differ from the input plan. Most notably, if any errors were encountered during execution, they will be caught and the error and stacktrace will be stored as strings in the error field.","category":"page"},{"location":"convert-to-onda/#Store-the-output","page":"Converting from EDF","title":"Store the output","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The final step is to store both the Onda.Samples and the executed plan in some persistent storage.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"For storing the plan, use Legolas.write(file_path, plan, FilePlanV4SchemaVersion()) on the results of OndaEDF.get_plan (see also the documentation for Legolas.write and FilePlanV4).","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"For storing Onda.Samples, see Onda.store, which supports serializing LPCM-encoded samples to any \"path-like\" type (i.e., anything that provides a method for write). OndaEDF.jl provides methods for Onda.store that accept ConvertedSamples and propagate missing samples.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Note that Onda.store requires at a minimum the file path (or \"path-like\" writeable), the format to use to serialize the samples (like \"lpcm\" or \"lpcm.zst\"), and the Samples themselves. However, this only serializes the samples to the file path. In most cases, you will want a signal record that can be stored elsewhere, which combines the path and file format to the serialized samples along with the SamplesInfo and other metadata required to be able to deserialize and use these samples. In this case, you should use the second Onda.store method which additionally requires:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"recording::UUID: the recording that this signal is associated with\nstart::Period: the start time of this signal relative to the start of the recording\nsensor_label::AbstractString: a unique label, defaults to the the sensor_label from the ConvertedSamples","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"While OndaEDF.jl generally creates sensor_labels which are valid when considering the EDF file alone, Onda requires that sensor_label be unique for the entire recording.  If you have signals from other sources that are associated with the same recording (e.g., different devices, multiple EDF files, etc.) that may have common sensor_types, you must ensure that the sensor_labels that you store the signals with are globally unique.","category":"page"},{"location":"convert-to-onda/#Example:-storing-samples-and-plan","page":"Converting from EDF","title":"Example: storing samples and plan","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"edf = EDF.File(edf_path)\nconverted_samples = edf_to_onda_samples(edf, plans)\n\n# generate SignalV2 rows\nstart_relative_to_recording = Second(0)\nsignals = map(converted_samples) do converted\n    return Onda.store(joinpath(\"samples\", recording, converted.sensor_label * \".lpcm\"),\n                      \"lpcm\", converted, recording, start_relative_to_recording)\nend\n\n# write combined signals table out\nLegolas.write(string(recording, \".onda.signal.arrow\"),\n              Onda.SignalV2SchemaVersion(),\n              skipmissing(signals))\n\n# write plan table out\nLegolas.write(string(recording, \".ondaedf.file-plan.arrow\"),\n              OndaEDF.FilePlanV4SchemaVersion(),\n              OndaEDF.get_plan(converted_samples))","category":"page"},{"location":"convert-to-onda/#Example:-generating-unique-sensor_labels","page":"Converting from EDF","title":"Example: generating unique sensor_labels","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Consider a case with parallel recordings from a traditional EEG system (received as an EDF) and some custom EEG hardware (which emits Onda-formatted data natively). Each device generates multichannel EEG data and uses sensor_type=\"eeg\". We must adjust the generated sensor labels for the EDF signals before storing them so that they are unique, which we can do by prepending \"edf_\" to the default, sensor_type-derived labels before storing:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"recording = uuid4()\nprototype_signals = ingest_prototype_device_as_onda(prototype_path, recording)\n\nedf = EDF.File(edf_path)\nplans = plan_edf_to_onda_samples(edf)\n\n# modify the plan before executing to prepend \"edf_\" to sensor labels:\nplans = map(plans) do plan\n    Legolas.record_merge(plan; recording, sensor_label=\"edf_\" * plan.sensor_label)\nend\n\nconverted_samples = edf_to_onda_samples(edf, plans)\n\nstart_relative_to_recording = Second(0)\nedf_signals = map(converted_samples) do converted\n    # `sensor_label` is automatically propagated from the `ConvertedSamples`:\n    return Onda.store(joinpath(\"samples\", recording, converted.sensor_label * \".lpcm\"),\n                      \"lpcm\", converted, recording, start_relative_to_recording)\nend\n\n# write combined signals table out\nall_signals = vcat(prototype_signals, skipmissing(edf_signals))\n@assert allunique(s.sensor_label for s in all_signals)\nLegolas.write(string(recording, \".onda.signal.arrow\"),\n              Onda.SignalV2SchemaVersion(),\n              all_signals)\n\n# write plan table out\nLegolas.write(string(recording, \".ondaedf.file-plan.arrow\"),\n              OndaEDF.FilePlanV4SchemaVersion(),\n              OndaEDF.get_plan(converted_samples))","category":"page"},{"location":"convert-to-onda/#Batch-conversion-of-many-EDFs","page":"Converting from EDF","title":"Batch conversion of many EDFs","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The workflow for bulk conversion of multiple EDFs is similar to the workflow for converting a single EDF. The major difference is that the \"planning\" steps can be conducted in bulk, while the \"execution\" steps (generally) need to be conducted one at a time, either serially or distributed across multiple workers. As discussed above, the planning stage requires only a few KB from the EDF file/signal headers, facilitating rapid plan-review-revise iteration of even fairly large collections of EDFs (10,000+).","category":"page"},{"location":"convert-to-onda/#Planning-multiple-EDFs","page":"Converting from EDF","title":"Planning multiple EDFs","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The main factor to consider when planning conversion of a large batch of EDF files is that planning requires only the (small number) of header bytes, even for very large EDF files. Thus, the first step is to read the file headers into memory without reading the signal data itself (which for more than a few EDF files will not usually fit into memory due to the large amount of signal data found in EDF files).","category":"page"},{"location":"convert-to-onda/#Reading-headers-from-local-filesystem","page":"Converting from EDF","title":"Reading headers from local filesystem","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"For EDF files stored on a normal filesystem, the EDF.File constructor will by default create a \"header-only\" EDF.File, so multiple files' headers can be read like","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"files = map(edf_paths) do path\n    open(EDF.File, path, \"r\")\nend","category":"page"},{"location":"convert-to-onda/#Reading-headers-from-S3","page":"Converting from EDF","title":"Reading headers from S3","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"note: Note\nThis section may become obsolete in a future version of EDF.jl which uses the conditional dependency functionality available from Julia 1.9+ to provide tighter integration with AWSS3.jl.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Unfortunately, open(path::S3Path) will fetch the entire contents of the object stored at path, so we need to be a bit clever to read only header bytes from an S3 file, especially given that the number of bytes we need to read depends on the number of signals. The following is an example of one technique for reading EDF file and signal headers from S3:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"function EDF.read_file_header(path::S3Path)\n    bytes = s3_get(path.bucket, path.key; byte_range=1:256)\n    buffer = IOBuffer(bytes)\n    return EDF.read_file_header(buffer)\nend\n\nfunction EDF.File(path::S3Path)\n    _, n_signals = EDF.read_file_header(path)\n    bytes = s3_get(path.bucket, path.key; byte_range=1:(256 * (n_signals + 1)))\n    return EDF.File(IOBuffer(bytes))\nend\n\n# use asyncmap because this is mostly bound by request roundtrip latency\nfiles = asyncmap(EDF.File, edf_paths)","category":"page"},{"location":"convert-to-onda/#Concatenating-plans-into-one-big-table","page":"Converting from EDF","title":"Concatenating plans into one big table","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"When doing bulk review of plans, it's generally helpful to have the individual files' plans concatenated into a single large table. It's important to keep track of which plan rows corresopnd to which input file, which can be accomplished via something like this:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"# create a UUID namespace to make recording ID generation idempotent\nconst NAMESPACE = UUID(...)\nfunction plan_all(edf_paths, files; kwargs...)\n    plans = mapreduce(vcat, edf_paths, files) do origin_uri, edf\n        plan = plan_edf_to_onda_samples(edf; kwargs...)\n        plan = DataFrame(plan)\n        # make sure this is the same every time this function is re-run!\n        recording = uuid5(NAMESPACE, string(origin_uri))\n        return insertcols!(plan,\n                           :origin_uri => origin_uri,\n                           :recording => recording)\n    end\nend","category":"page"},{"location":"convert-to-onda/#Review-and-revise-the-plans","page":"Converting from EDF","title":"Review and revise the plans","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"This \"bulk plan\" table can then be reviewed in bulk, looking for patterns in which labels are not matched, physical units associated with each sensor_type, etc. At a minimum, we find it useful to print some basic counts:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"plans = plan_all(...)\n# helper function to tally rows per group\ntally(df, g, agg...=nrow => :count) = combine(groupby(df, g), agg...)\nunmatched_labels = filter(:channel => ismissing, plans)\n@info \"unmatched labels:\" tally(unmatched_labels, :label)\n\nunmatched_units = filter(:sample_unit => ismissing, plans)\n@info \"unmatched labels:\" tally(unmatched_units, :physical_dimension)\n\nmatched = subset(plans, :channel => ByRow(!ismissing), :sample_unit => ByRow(!ismissing))\n@info \"matched sensor types/channels:\" tally(matched, [:sensor_type, :channel, :sample_unit])","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Reviewing these summaries is a good first step when revising the plans. The revision process is basically the same as with a single EDF: update the labels= and units= as needed to capture any un-matched EDF signals, and failing that, preprocess the headers/postprocess the plan. Note that if it is necessary to run plan_edf_to_onda_samples_groups, this must be done one file at a time, using something like this to preserve the recording-level keys created above:","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"new_plans = combine(groupby(plans, [:recording, :origin_uri])) do plan\n    new_plan = plan_edf_to_onda_samples_groups(Tables.rows(plan))\n    return DataFrame(new_plan)\nend","category":"page"},{"location":"convert-to-onda/#Executing-bulk-plans-and-storing-generated-samples","page":"Converting from EDF","title":"Executing bulk plans and storing generated samples","text":"","category":"section"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"The last step, as with single EDF conversion, is to execute the plans. Given that this requires loading signal data into memory, it's generally necessary to do this one recording at a time, either serially on a single process or using multiprocessing to distribute work over different processes or even machines. A complete introduction to multiprocessing in Julia is outside the scope of this guide, but we offer a few pointers in the hope that we can help avoid common pitfalls.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"First, it's generally a good idea to create a function that accepts one recording's plan, EDF file path, and recording ID (or generally any additional metadata that is required to create a persistent record), which will execute the plan and persistently store the resulting samples and executed plan. This function then may return either the generated Onda.SignalV2 and OndaEDF.FilePlanV2 tables for the completed recording, or pointers to where these are stored. This way, the memory pressure involved in loading an entire EDF's signal data is confined to function scope which makes it slightly easier for Julia's garbage collector.","category":"page"},{"location":"convert-to-onda/","page":"Converting from EDF","title":"Converting from EDF","text":"Second, a separate function should handle coordinating these individual jobs and then collecting these results into the ultimate aggregate signal and plan tables, and then persistently storing those to a final destination.","category":"page"},{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Import-EDF-to-Onda","page":"API Documentation","title":"Import EDF to Onda","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"OndaEDF.jl prefers \"self-service\" import over \"automagic\", and provides functionality to extract Onda.Samples and EDFAnnotationV1s (which extend Onda.AnnotationV1s) from an EDF.File.  These can be written to disk (with Onda.store / Legolas.write or manipulated in memory as desired.","category":"page"},{"location":"api/#Import-signal-data-as-Samples","page":"API Documentation","title":"Import signal data as Samples","text":"","category":"section"},{"location":"api/#Import-planning","page":"API Documentation","title":"Import planning","text":"","category":"section"},{"location":"api/#OndaEDF.plan_edf_to_onda_samples","page":"API Documentation","title":"OndaEDF.plan_edf_to_onda_samples","text":"plan_edf_to_onda_samples(header, seconds_per_record; labels=STANDARD_LABELS,\n                         units=STANDARD_UNITS)\nplan_edf_to_onda_samples(signal::EDF.Signal, args...; kwargs...)\n\nFormulate a plan for converting an EDF signal into Onda format.  This returns a Tables.jl row with all the columns from the signal header, plus additional columns for the Onda.SamplesInfo for this signal, and the seconds_per_record that is passed in here.\n\nIf no labels match, then the channel and sensor_type columns are missing; the behavior of other SamplesInfo columns is undefined; they are currently set to missing but that may change in future versions.\n\nAny errors that are thrown in the process will be wrapped as SampleInfoErrors and then printed with backtrace to a String in the error column.\n\nMatching EDF label to Onda labels\n\nThe labels keyword argument determines how Onda channel and signal sensor_type are extracted from the EDF label.\n\nLabels are specified as an iterable of signal_names => channel_names pairs. signal_names should be an iterable of signal names, the first of which is the canonical name used as the Onda sensor_type.  Each element of channel_names gives the specification for one channel, which can either be a string, or a canonical_name => alternates pair.  Occurences of alternates will be replaces with canonical_name in the generated channel label.\n\nMatching is determined solely by the channel names.  When matching, the signal names are only used to remove signal names occuring as prefixes (e.g., \"[ECG] AVL\") before matching channel names.  See match_edf_label for details, and see OndaEDF.STANDARD_LABELS for the default labels.\n\nAs an example, here is (a subset of) the default labels for ECG signals:\n\n[\"ecg\", \"ekg\"] => [\"i\" => [\"1\"], \"ii\" => [\"2\"], \"iii\" => [\"3\"],\n                   \"avl\"=> [\"ecgl\", \"ekgl\", \"ecg\", \"ekg\", \"l\"],\n                   \"avr\"=> [\"ekgr\", \"ecgr\", \"r\"], ...]\n\nMatching is done in the order that labels iterates pairs, and will stop at the first match, with no warning if signals are ambiguous (although this may change in a future version)\n\n\n\n\n\nplan_edf_to_onda_samples(edf::EDF.File;\n                         labels=STANDARD_LABELS,\n                         units=STANDARD_UNITS,\n                         extra_onda_signal_groupby=())\n\nFormulate a plan for converting an EDF.File to Onda Samples.  This applies plan_edf_to_onda_samples to each individual signal contained in the file, storing edf_signal_index as an additional column.\n\nThe resulting rows are then passed to plan_edf_to_onda_samples_groups and grouped according to the :sensor_type, :sample_unit, and :sample_rate columns, as well as any additional columns specified in extra_onda_signal_groupby.  A sensor_label is generated for each group, based on the sensor_type but with a numeric suffix _n for the nth occurance of a sensor_type after the first.\n\nThe resulting plan is returned as a table.  No signal data is actually read from the EDF file; to execute this plan and generate Onda.Samples, use edf_to_onda_samples.  The index of the EDF signal (after filtering out signals that are not EDF.Signals, e.g. annotation channels) for each row is stored in the :edf_signal_index column, and the rows are sorted in order of :sensor_label, and then by :edf_signal_index.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.plan_edf_to_onda_samples_groups","page":"API Documentation","title":"OndaEDF.plan_edf_to_onda_samples_groups","text":"plan_edf_to_onda_samples_groups(plan_rows; extra_onda_signal_groupby=())\n\nGroup together plan_rows based on the values of the :sensor_type, :sample_unit, :sample_rate, and extra_onda_signal_groupby columns, creating a unique :sensor_label per group and and promoting the Onda encodings for each group using OndaEDF.promote_encodings.  All rows with the same :sensor_label will be combined into a single Onda Samples by edf_to_onda_samples.\n\nIf the :edf_signal_index column is not present or otherwise missing, it will be filled in based on the order of the input rows.\n\nThe updated rows are returned, sorted first by the grouping columns and second by order of occurrence within the input rows.\n\n\n\n\n\n","category":"function"},{"location":"api/#Import-execution","page":"API Documentation","title":"Import execution","text":"","category":"section"},{"location":"api/#OndaEDF.edf_to_onda_samples","page":"API Documentation","title":"OndaEDF.edf_to_onda_samples","text":"edf_to_onda_samples(edf::EDF.File, plan_table; validate=true, dither_storage=missing)\n\nConvert Signals found in an EDF File to Onda.Samples according to the plan specified in plan_table (e.g., as generated by plan_edf_to_onda_samples).  Returns a Vector{ConvertedSamples}; use get_plan and get_samples to extract the executed plan and Onda.Samples respectively.\n\nThe input plan is transformed by using merge_samples_info to combine rows with the same :sensor_label into a common Onda.SamplesInfo.  Then OndaEDF.onda_samples_from_edf_signals is used to combine the EDF signals data into a single Onda.Samples per group.\n\nAny errors that occur are shown as Strings (with backtrace) and inserted into the :error column for the corresponding rows from the plan.\n\nSamples are returned in the order that their corresponding :sensor_label occurs in the plan.  All EDF Signals from the plan with the same plan :sensor_label are combined into a single Onda.Samples, in order of :edf_signal_index.  Signals that could not be matched, where :sensor_label is missing, or otherwise caused an error during execution are not returned.\n\nIf validate=true (the default), the plan is validated against the FilePlanV4 schema, and the signal headers in the EDF.File.\n\nIf dither_storage=missing (the default), dither storage is allocated automatically as specified in the docstring for Onda.encode. dither_storage=nothing disables dithering.\n\nwarning: Warning\nReturned samples are integer-encoded. If these samples are being serialized out (e.g. via Onda.store!) this is not an issue, but if the samples are being immediately analyzed in memory, call Onda.decode to decode them to recover the time-series voltages.\n\n\n\n\n\nedf_to_onda_samples(edf::EDF.File; kwargs...)\n\nRead signals from an EDF.File into a Vector{ConvertedSamples}. This is a convenience function that first formulates an import plan via plan_edf_to_onda_samples, and then immediately executes this plan with edf_to_onda_samples.\n\nwarning: Warning\nThis function is provided as a convenience for \"quick and dirty\" exploration.  In general, it is strongly adivsed to review the plan and make any necessary adjustments before execution.\n\nA Vector{ConvertedSamples} is returned; use get_plan and get_samples to extract the executed plan and Onda.Samples respectively.  It is strongly advised that you review the output for un-extracted signals by investigating any ConvertedSamples where the .samples are missing.  Run-time errors during conversion are stored in the :error column of the .channel_plans, and any EDF Signals that could not be matched will have missing values in their .channel_plans for :sensor_type, :channel, or :physical_unit.\n\nCollections of EDF.Signals are mapped as channels to Onda.Samples via plan_edf_to_onda_samples.  The caller of this function can control the plan via the labels and units keyword arguments, all of which are forwarded to plan_edf_to_onda_samples.  If more control is required, first generate the plan, review and edit it as needed, and then execute by passing it as the second argument to edf_to_onda_samples.\n\nEDF.Signal labels that are converted into Onda channel names undergo the following transformations:\n\nthe label is whitespace-stripped, parens-stripped, and lowercased\ntrailing generic EDF references (e.g. \"ref\", \"ref2\", etc.) are dropped\nany instance of + is replaced with _plus_ and / with _over_\nall component names are converted to their \"canonical names\" when possible (e.g. \"m1\" in an EEG-matched channel name will be converted to \"a1\").\n\nSee the OndaEDF README for additional details regarding EDF formatting expectations.\n\nwarning: Warning\nReturned samples are integer-encoded. If these samples are being serialized out (e.g. via Onda.store!) this is not an issue, but if the samples are being immediately analyzed in memory, call Onda.decode to decode them to recover the time-series voltages.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.ConvertedSamples","page":"API Documentation","title":"OndaEDF.ConvertedSamples","text":"struct ConvertedSamples\n    samples::Union{Samples,Missing}\n    channel_plans::Vector{FilePlanV4}\n    sensor_label::Union{String,Missing}\nend\n\nRepresents a group of EDF.Signals which have been converted into a single Onda.Samples (e.g. by edf_to_onda_samples).  The channel_plans are the FilePlanV4s that were used to do the conversion.  The sensor_label field is the single unique value of the sensor_label fields of the channel_plans.\n\nIf conversion failed for any reason, samples will be missing.  Any runtime errors encountered during conversion will be stored in the error field of the channel_plans.\n\nConvenience functions for storing converted samples\n\nThe converted samples are in-memory Onda.Samples objects that usually need to be persisted to some external storage.  OndaEDF.jl implements methods for Onda.store with a ConvertedSamples argument which will extract the wrapped samples and Onda.store them.  When the wrapped samples are missing, these methods return missing. When the Onda.SignalV2-returning method with arguments for recording and start is called, the sensor_label is propagated by default (but may be overridden).\n\nConvenience functions for EDF.File-level collections\n\nConversion of an entire EDF.File via edf_to_onda_samples returns a Vector{ConvertedSamples}.\n\nThe get_plan function will collate the plans for a Vector{ConvertedSamples} into a single table that is suitable for passing to Legolas.write.\n\nThe get_samples function extracts the converted samples from a Vector{ConvertedSamples}.  By default, this function will skip any samples that are missing, unless called with a keyword argument skipmissing=false.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDF.get_plan","page":"API Documentation","title":"OndaEDF.get_plan","text":"get_plan(cs::AbstractVector{ConvertedSamples})\n\nExtract the \"executed plan\" table from a collection of ConvertedSamples output from edf_to_onda_samples.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.get_samples","page":"API Documentation","title":"OndaEDF.get_samples","text":"get_samples(cs::AbstractVector{ConvertedSamples}; skipmissing=true)\n\nExtract the Onda.Samples from a collection of ConvertedSamples output from edf_to_onda_samples.\n\nIf skipmissing=true (the default), only successfully converted samples will be returned.  If skipmissing=false, then some elements may be missing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Onda.store","page":"API Documentation","title":"Onda.store","text":"Onda.store(file_path, file_format, samples::ConvertedSamples)\nOnda.store(file_path, file_format, samples::ConvertedSamples, recording, start,\n           sensor_label=samples.sensor_label)\n\nConvertedSamples (as output from edf_to_onda_samples) may be stored via Onda.store.  If the conversion failed and the wrapped .samples are missing, then this returns missing.\n\nIf a recording UUID and start Period are provided, a Onda.SignalV2 record will be returned pointing to the stored samples, with the sensor_label taken from the converted samples.\n\n\n\n\n\n","category":"function"},{"location":"api/#Import-annotations","page":"API Documentation","title":"Import annotations","text":"","category":"section"},{"location":"api/#OndaEDF.edf_to_onda_annotations","page":"API Documentation","title":"OndaEDF.edf_to_onda_annotations","text":"edf_to_onda_annotations(edf::EDF.File, uuid::UUID)\n\nExtract EDF+ annotations from an EDF.File for recording with ID uuid and return them as a vector of Onda.Annotations.  Each returned annotation has a  value field that contains the string value of the corresponding EDF+ annotation.\n\nIf no EDF+ annotations are found in edf, then an empty Vector{Annotation} is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDFSchemas.EDFAnnotationV1","page":"API Documentation","title":"OndaEDFSchemas.EDFAnnotationV1","text":"@version EDFAnnotationV1 > AnnotationV1 begin\n    value::String\nend\n\nA Legolas-generated record type that represents a single annotation imported from an EDF Annotation signal.  The value field contains the annotation value as a string.\n\n\n\n\n\n","category":"type"},{"location":"api/#Import-plan-table-schemas","page":"API Documentation","title":"Import plan table schemas","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"note: Plan version is dependent on EDF.jl version\nThe utilized plan version is dependent on the EDF.jl version. For EDF.jl 0.8+, V3 are used, while V2 is used for for EDF.jl 0.7. The change from V2 to V3 reflects the change from Int16 to Int32 in EDF.jl's samples_per_record.","category":"page"},{"location":"api/#OndaEDFSchemas.PlanV4","page":"API Documentation","title":"OndaEDFSchemas.PlanV4","text":"@version PlanV4 begin\n    # EDF.SignalHeader fields\n    label::String\n    transducer_type::String\n    physical_dimension::String\n    physical_minimum::Float32\n    physical_maximum::Float32\n    digital_minimum::Float32\n    digital_maximum::Float32\n    prefilter::String\n    samples_per_record::Int32\n    # EDF.FileHeader field\n    seconds_per_record::Float64\n    # Onda.SignalV4 fields (channels -> channel), may be missing\n    sensor_type::Union{Missing,AbstractString}\n    channel::Union{Missing,AbstractString}\n    sample_unit::Union{Missing,AbstractString}\n    sample_resolution_in_unit::Union{Missing,Float64}\n    sample_offset_in_unit::Union{Missing,Float64}\n    sample_type::Union{Missing,AbstractString}\n    sample_rate::Union{Missing,Float64}\n    # errors, use `nothing` to indicate no error\n    error::Union{Nothing,String}\nend\n\nA Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of\n\nfields from EDF.SignalHeader (all mandatory)\nthe seconds_per_record field from EDF.FileHeader (mandatory)\nfields from Onda.SignalV4 (optional, may be missing to indicate failed conversion), except for file_path\nerror, which is nothing for a conversion that is or is expected to be successful, and a String describing the source of the error (with backtrace) in the case of a caught error.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.FilePlanV4","page":"API Documentation","title":"OndaEDFSchemas.FilePlanV4","text":"@version FilePlanV4 > PlanV4 begin\n    recording::Union{UUID,Missing} = lift(UUID, recording)\n    edf_signal_index::Int\n    sensor_label::Union{String,Missing}\nend\n\nA Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a PlanV4 and additional file-level context:\n\nrecording::Union{UUID,Missing} the UUID of the recording, if known.\nedf_signal_index gives the index of the signals in the source EDF.File corresponding to this row\nsensor_label::AbstractString gives the unique identifier of the corresponding output Onda.Samples after conversion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Full-service-import","page":"API Documentation","title":"Full-service import","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"For a more \"full-service\" experience, OndaEDF.jl also provides functionality to extract Onda.Samples and EDFAnnotationV1s and then write them to disk:","category":"page"},{"location":"api/#OndaEDF.store_edf_as_onda","page":"API Documentation","title":"OndaEDF.store_edf_as_onda","text":"store_edf_as_onda(edf::EDF.File, onda_dir, recording_uuid::UUID=uuid4();\n                  custom_extractors=STANDARD_EXTRACTORS, import_annotations::Bool=true,\n                  signals_prefix=\"edf\", annotations_prefix=signals_prefix)\n\nConvert an EDF.File to Onda.Samples and Onda.Annotations, store the samples in $path/samples/, and write the Onda signals and annotations tables to $path/$(signals_prefix).onda.signals.arrow and $path/$(annotations_prefix).onda.annotations.arrow.  The default prefix is \"edf\", and if a prefix is provided for signals but not annotations both will use the signals prefix.  The prefixes cannot reference (sub)directories.\n\nReturns (; recording_uuid, signals, annotations, signals_path, annotations_path, plan).\n\nThis is a convenience function that first formulates an import plan via plan_edf_to_onda_samples, and then immediately executes this plan with edf_to_onda_samples.\n\nThe samples and executed plan are returned; it is strongly advised that you review the plan for un-extracted signals (where :sensor_type or :channel is missing) and errors (non-nothing values in :error).\n\nGroups of EDF.Signals are mapped as channels to Onda.Samples via plan_edf_to_onda_samples.  The caller of this function can control the plan via the labels and units keyword arguments, all of which are forwarded to plan_edf_to_onda_samples.\n\nEDF.Signal labels that are converted into Onda channel names undergo the following transformations:\n\nthe label is whitespace-stripped, parens-stripped, and lowercased\ntrailing generic EDF references (e.g. \"ref\", \"ref2\", etc.) are dropped\nany instance of + is replaced with _plus_ and / with _over_\nall component names are converted to their \"canonical names\" when possible (e.g. \"3\" in an ECG-matched channel name will be converted to \"iii\").\n\nIf more control (e.g. preprocessing signal labels) is required, callers should use plan_edf_to_onda_samples and edf_to_onda_samples directly, and Onda.store the resulting samples manually.\n\nSee the OndaEDF README for additional details regarding EDF formatting expectations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-import-utilities","page":"API Documentation","title":"Internal import utilities","text":"","category":"section"},{"location":"api/#OndaEDF.match_edf_label","page":"API Documentation","title":"OndaEDF.match_edf_label","text":"OndaEDF.match_edf_label(label, signal_names, channel_name, canonical_names)\n\nReturn a normalized label matched from an EDF label.  The purpose of this function is to remove signal names from the label, and to canonicalize the channel name(s) that remain.  So something like \"[eCG] avl-REF\" will be transformed to \"avl\" (given signal_names=[\"ecg\"], and channel_name=\"avl\")\n\nThis returns nothing if channel_name does not match after normalization.\n\nCanonicalization\n\nensures the given label is whitespace-stripped, lowercase, and parens-free\nstrips trailing generic EDF references (e.g. \"ref\", \"ref2\", etc.)\nreplaces all references with the appropriate name as specified by canonical_names\nreplaces + with _plus_ and / with _over_\nreturns the initial reference name (w/o prefix sign, if present) and the entire label; the initial reference name should match the canonical channel name, otherwise the channel extraction will be rejected.\n\nExamples\n\nmatch_edf_label(\"[ekG]  avl-REF\", [\"ecg\", \"ekg\"], \"avl\", []) == \"avl\"\nmatch_edf_label(\"ECG 2\", [\"ecg\", \"ekg\"], \"ii\", [\"ii\" => [\"2\", \"two\", \"ecg2\"]]) == \"ii\"\n\nSee the tests for more examples\n\nnote: Note\nThis is an internal function and is not meant to be called directly.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.merge_samples_info","page":"API Documentation","title":"OndaEDF.merge_samples_info","text":"OndaEDF.merge_samples_info(plan_rows)\n\nCreate a single, merged SamplesInfo from plan rows, such as generated by plan_edf_to_onda_samples.  Encodings are promoted with promote_encodings.\n\nThe input rows must have the same values for :sensor_type, :sample_unit, and :sample_rate; otherwise an ArgumentError is thrown.\n\nIf any of these values is missing, or any row's :channel value is missing, this returns missing to indicate it is not possible to determine a shared SamplesInfo.\n\nThe original EDF labels are included in the output in the :edf_channels column.\n\nnote: Note\nThis is an internal function and is not meant to be called direclty.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.onda_samples_from_edf_signals","page":"API Documentation","title":"OndaEDF.onda_samples_from_edf_signals","text":"OndaEDF.onda_samples_from_edf_signals(target::Onda.SamplesInfo, edf_signals,\n                                      edf_seconds_per_record; dither_storage=missing)\n\nGenerate an Onda.Samples struct from an iterable of EDF.Signals, based on the Onda.SamplesInfo in target.  This checks for matching sample rates in the source signals.  If the encoding of target is the same as the encoding in a signal, its encoded (usually Int16) data is copied directly into the Samples data matrix; otherwise it is re-encoded.\n\nIf dither_storage=missing (the default), dither storage is allocated automatically as specified in the docstring for Onda.encode. dither_storage=nothing disables dithering. See Onda.encode's docstring for more details.\n\nnote: Note\nThis function is not meant to be called directly, but through edf_to_onda_samples\n\nwarning: Warning\nReturned samples are integer-encoded. If these samples are being serialized out (e.g. via Onda.store!) this is not an issue, but if the samples are being immediately analyzed in memory, call Onda.decode to decode them to recover the time-series voltages.\n\n\n\n\n\n","category":"function"},{"location":"api/#OndaEDF.promote_encodings","page":"API Documentation","title":"OndaEDF.promote_encodings","text":"promote_encodings(encodings; pick_offset=(_ -> 0.0), pick_resolution=minimum)\n\nReturn a common encoding for input encodings, as a NamedTuple with fields sample_type, sample_offset_in_unit, sample_resolution_in_unit, and sample_rate.  If input encodings' sample_rates are not all equal, an error is thrown.  If sample rates/offests are not equal, then pick_offset and pick_resolution are used to combine them into a common offset/resolution.\n\nnote: Note\nThis is an internal function and is not meant to be called direclty.\n\n\n\n\n\n","category":"function"},{"location":"api/#Export-EDF-from-Onda","page":"API Documentation","title":"Export EDF from Onda","text":"","category":"section"},{"location":"api/#OndaEDF.onda_to_edf","page":"API Documentation","title":"OndaEDF.onda_to_edf","text":"onda_to_edf(samples::AbstractVector{<:Samples}, annotations=[]; kwargs...)\n\nReturn an EDF.File containing signal data converted from a collection of Onda Samples and (optionally) annotations from an annotations table.\n\nFollowing the Onda v0.5 format, annotations can be any Tables.jl-compatible table (DataFrame, Arrow.Table, NamedTuple of vectors, vector of NamedTuples) which follows the annotation schema.\n\nEach EDF.Signal in the returned EDF.File corresponds to a channel of an input Onda.Samples.\n\nThe ordering of EDF.Signals in the output will match the order of the input collection of Samples (and within each channel grouping, the order of the samples' channels).\n\nnote: Note\nEDF signals are encoded as Int16, while Onda allows a range of different sample types, some of which provide considerably more resolution than Int16. During export, re-encoding may be necessary if the encoded Onda samples cannot be represented directly as Int16 values.  In this case, new encoding (resolution and offset) will be chosen based on the minimum and maximum values actually present in each signal in the input Onda Samples.  Thus, it may not always be possible to losslessly round trip Onda-formatted datasets to EDF and back.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-export-utilities","page":"API Documentation","title":"Internal export utilities","text":"","category":"section"},{"location":"api/#OndaEDF.reencode_samples","page":"API Documentation","title":"OndaEDF.reencode_samples","text":"reencode_samples(samples::Samples, sample_type::Type{<:Integer}=Int16)\n\nEncode samples so that they can be stored as sample_type.  The default sample_type is Int16 which is the target for EDF format.  The returned Samples will be encoded, with a info.sample_type that is either equal to sample_type or losslessly convertible.\n\nIf the info.sample_type of the input samples cannot be losslessly converted to sample_type, new quantization settings are chosen based on the actual signal extrema, choosing a resolution/offset that maps them to typemin(sample_type), typemax(sample_type).\n\nReturns an encoded Samples, possibly with updated info.  If the current encoded values can be represented with sample_type, the .info is not changed.  If they cannot, the sample_type, sample_resolution_in_unit, and sample_offset_in_unit fields are changed to reflect the new encoding.\n\n\n\n\n\n","category":"function"},{"location":"api/#Deprecations","page":"API Documentation","title":"Deprecations","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"To support deserializing plan tables generated with old versions of OndaEDF + Onda, the following schemas are provided.  These are deprecated and will be removed in a future release.","category":"page"},{"location":"api/#OndaEDFSchemas.PlanV1","page":"API Documentation","title":"OndaEDFSchemas.PlanV1","text":"@version PlanV1 begin\n    # EDF.SignalHeader fields\n    label::String\n    transducer_type::String\n    physical_dimension::String\n    physical_minimum::Float32\n    physical_maximum::Float32\n    digital_minimum::Float32\n    digital_maximum::Float32\n    prefilter::String\n    samples_per_record::Int16\n    # EDF.FileHeader field\n    seconds_per_record::Float64\n    # Onda.SignalV1 fields (channels -> channel), may be missing\n    recording::Union{UUID,Missing} = passmissing(UUID)\n    kind::Union{Missing,AbstractString}\n    channel::Union{Missing,AbstractString}\n    sample_unit::Union{Missing,AbstractString}\n    sample_resolution_in_unit::Union{Missing,Float64}\n    sample_offset_in_unit::Union{Missing,Float64}\n    sample_type::Union{Missing,AbstractString}\n    sample_rate::Union{Missing,Float64}\n    # errors, use `nothing` to indicate no error\n    error::Union{Nothing,String}\nend\n\nA Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of\n\nfields from EDF.SignalHeader (all mandatory)\nthe seconds_per_record field from EDF.FileHeader (mandatory)\nfields from Onda.SignalV1 (optional, may be missing to indicate failed conversion), except for file_path\nerror, which is nothing for a conversion that is or is expected to be successful, and a String describing the source of the error (with backtrace) in the case of a caught error.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.PlanV2","page":"API Documentation","title":"OndaEDFSchemas.PlanV2","text":"@version PlanV2 begin\n    # EDF.SignalHeader fields\n    label::String\n    transducer_type::String\n    physical_dimension::String\n    physical_minimum::Float32\n    physical_maximum::Float32\n    digital_minimum::Float32\n    digital_maximum::Float32\n    prefilter::String\n    samples_per_record::Int16\n    # EDF.FileHeader field\n    seconds_per_record::Float64\n    # Onda.SignalV2 fields (channels -> channel), may be missing\n    recording::Union{UUID,Missing} = passmissing(UUID)\n    sensor_type::Union{Missing,AbstractString}\n    sensor_label::Union{Missing,AbstractString}\n    channel::Union{Missing,AbstractString}\n    sample_unit::Union{Missing,AbstractString}\n    sample_resolution_in_unit::Union{Missing,Float64}\n    sample_offset_in_unit::Union{Missing,Float64}\n    sample_type::Union{Missing,AbstractString}\n    sample_rate::Union{Missing,Float64}\n    # errors, use `nothing` to indicate no error\n    error::Union{Nothing,String}\nend\n\nA Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of\n\nfields from EDF.SignalHeader (all mandatory)\nthe seconds_per_record field from EDF.FileHeader (mandatory)\nfields from Onda.SignalV2 (optional, may be missing to indicate failed conversion), except for file_path\nerror, which is nothing for a conversion that is or is expected to be successful, and a String describing the source of the error (with backtrace) in the case of a caught error.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.PlanV3","page":"API Documentation","title":"OndaEDFSchemas.PlanV3","text":"@version PlanV3 begin\n    # EDF.SignalHeader fields\n    label::String\n    transducer_type::String\n    physical_dimension::String\n    physical_minimum::Float32\n    physical_maximum::Float32\n    digital_minimum::Float32\n    digital_maximum::Float32\n    prefilter::String\n    samples_per_record::Int32\n    # EDF.FileHeader field\n    seconds_per_record::Float64\n    # Onda.SignalV3 fields (channels -> channel), may be missing\n    recording::Union{UUID,Missing} = passmissing(UUID)\n    sensor_type::Union{Missing,AbstractString}\n    sensor_label::Union{Missing,AbstractString}\n    channel::Union{Missing,AbstractString}\n    sample_unit::Union{Missing,AbstractString}\n    sample_resolution_in_unit::Union{Missing,Float64}\n    sample_offset_in_unit::Union{Missing,Float64}\n    sample_type::Union{Missing,AbstractString}\n    sample_rate::Union{Missing,Float64}\n    # errors, use `nothing` to indicate no error\n    error::Union{Nothing,String}\nend\n\nA Legolas-generated record type describing a single EDF signal-to-Onda channel conversion.  The columns are the union of\n\nfields from EDF.SignalHeader (all mandatory)\nthe seconds_per_record field from EDF.FileHeader (mandatory)\nfields from Onda.SignalV3 (optional, may be missing to indicate failed conversion), except for file_path\nerror, which is nothing for a conversion that is or is expected to be successful, and a String describing the source of the error (with backtrace) in the case of a caught error.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.FilePlanV1","page":"API Documentation","title":"OndaEDFSchemas.FilePlanV1","text":"@version FilePlanV1 > PlanV1 begin\n    edf_signal_index::Int\n    onda_signal_index::Int\nend\n\nA Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a PlanV1 and additional file-level context:\n\nedf_signal_index gives the index of the signals in the source EDF.File corresponding to this row\nonda_signal_index gives the index of the output Onda.Samples.\n\nNote that while the EDF index does correspond to the actual index in edf.signals, some Onda indices may be skipped in the output, so onda_signal_index is only to indicate order and grouping.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.FilePlanV2","page":"API Documentation","title":"OndaEDFSchemas.FilePlanV2","text":"@version FilePlanV2 > PlanV2 begin\n    edf_signal_index::Int\n    onda_signal_index::Int\nend\n\nA Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a PlanV2 and additional file-level context:\n\nedf_signal_index gives the index of the signals in the source EDF.File corresponding to this row\nonda_signal_index gives the index of the output Onda.Samples.\n\nNote that while the EDF index does correspond to the actual index in edf.signals, some Onda indices may be skipped in the output, so onda_signal_index is only to indicate order and grouping.\n\n\n\n\n\n","category":"type"},{"location":"api/#OndaEDFSchemas.FilePlanV3","page":"API Documentation","title":"OndaEDFSchemas.FilePlanV3","text":"@version FilePlanV3 > PlanV3 begin\n    edf_signal_index::Int\n    onda_signal_index::Int\nend\n\nA Legolas-generated record type representing one EDF signal-to-Onda channel conversion, which includes the columns of a PlanV3 and additional file-level context:\n\nedf_signal_index gives the index of the signals in the source EDF.File corresponding to this row\nonda_signal_index gives the index of the output Onda.Samples.\n\nNote that while the EDF index does correspond to the actual index in edf.signals, some Onda indices may be skipped in the output, so onda_signal_index is only to indicate order and grouping.\n\n\n\n\n\n","category":"type"},{"location":"#OndaEDF","page":"OndaEDF","title":"OndaEDF","text":"","category":"section"},{"location":"","page":"OndaEDF","title":"OndaEDF","text":"","category":"page"}]
}
